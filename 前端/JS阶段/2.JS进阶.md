## JavaScript进阶
::: tip 主要考察点
原型继承、this 关键字的绑定、事件循环与任务队列、Promise 和 async/await、函数式编程、模块化机制、内存管理以及性能调优技巧。
:::

### 说说你对 fetch 的理解，它有哪些优点和不足 ?
#### 含义
Fetch 是现代 JavaScript 中用于进行网络请求的 API。
它是基于 Promise 的，在替代传统的 XMLHttpRequest (XHR) 做网络请求时提供了一种更简单、更直观的编码方式。
#### 优点
- 简洁和直观：
  - 语法更加简洁，没有回调地狱，更类似于现代 JavaScript 的编程风格。
- 基于 Promise：
  - 使得处理异步操作更加优雅，可以使用 then 和 catch 处理成功和失败的情况，也可以结合 async/await 使代码更易读。
- 更好的错误处理：
  - 不会仅仅在网络错误时触发 reject 状态，4xx 和 5xx 的 HTTP 响应状态不会自动被视为错误，需开发者自行处理。
- 更丰富的功能：
  - 支持请求/响应拦截、请求取消以及更多控制的能力，例如可以通过设置 mode 字段来控制跨域请求。
#### 不足及应对策略
- 不可中断：
  - 标准 Fetch 请求一旦发起，无法中途取消，尽管后来引入了 AbortController 来提供解决方案，但它依旧不如其他一些请求库来的方便。
  - 可以使用 AbortController 和 signal 实现请求取消操作
- 错误处理复杂：
  - 需要自己手动处理 HTTP 错误情况，比如 404 或 500，不像其他库那样自动处理。
  - 其他库: axios
- 不支持所有浏览器：
  - 部分老旧的浏览器不支持 Fetch 比如 IE，这样的场景下需要使用 polyfill 或者退回到 XHR。
  - 使用 polyfill，例如 whatwg-fetch 来为它们添加支持
- 不支持进度监控：
  - 无法监控请求上传或下载的进度，而 XMLHttpRequest 是支持的。
  - 结合 ReadableStream 来实现一些简单的方案
#### 补充
```js
const controller = new AbortController();
const signal = controller.signal;

fetch('/some-api', { signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(err => {
    if (err.name === 'AbortError') {
      console.log('Fetch aborted');
    } else {
      console.error('Fetch error:', err);
    }
});

// 中途取消请求
controller.abort();
```

### JavaScript 中 Object.keys 的返回值是无序的吗 ?
在 JavaScript 中，Object.keys 方法返回一个数组，该数组的元素是一个对象自身可枚举属性的字符串键。
尽管对象的属性在 ECMAScript 标准中没有明确的顺序要求，但现代 JavaScript 引擎对对象的属性顺序做出了一定保证，因此我们通常可以认为 Object.keys 返回值是有序的。

更具体地，Object.keys 返回的数组顺序遵循以下规则：
- 所有键为整数类型的属性按从小到大排序。
- 所有字符串类型键按创建的顺序排序。
- 所有 symbol 类型的键按创建的顺序排序。
#### 补充
- 整数类型键顺序：
在 JavaScript 中，属性名可以是字符串或符号，但在 Object.keys 中，如果属性名看起来像一个整数（例如 "1", "2", "42"），这些属性会按数值顺序排列并出现在数组的前部分。
- 字符串类型键顺序：
非整数类型的字符串键会严格按照它们被创建的顺序排列。
这条规则意味着，如果你在对象上定义了一堆字符串属性，这些属性会按照你定义它们的顺序在 Object.keys 输出的数组中出现。
- 符号类型键：
要了解完整的属性顺序，我们需要提到符号键。
尽管 Object.keys 不会返回符号键，但符号键在对象内部的顺序按它们被创建的顺序排列。
在 Object.getOwnPropertyNames 或反射式的方法 (Reflect.ownKeys) 中，你可以看到它们排列的顺序。
- 实际应用和注意事项：
虽然以上顺序已经在现代 JavaScript 引擎中得到很好的支持，例如 V8 引擎（用于 Chrome 和 Node.js）和 SpiderMonkey 引擎（用于 Firefox），但在一些较老的或非标准的引擎中，不一定会遵从这些规则。
所以，如果你在面对较老版本的 JavaScript 引擎时，还是要谨慎些，最好不要依赖对象属性的顺序。
- ES6 中 Map 的使用：
如果你确实需要一个可以保证键值顺序的数据结构，可以考虑使用 ES6 引入的 Map 对象。Map 保证了按照插入顺序的迭代顺序，这是一个显著的优点。
在某些场景下，利用 Map 而不是普通的对象能让代码更加可靠和可预测。

### JavaScript 的 BigInt 和 Number 类型有什么区别 ?
- 数值范围：
  - Number: 大约从 -2^53 到 2^53 之间。
  - BigInt: 可以表示非常大的整数(远超 Number 的范围)。
- 数据类型：
  - Number: 任意大小的浮点数。
  - BigInt: 仅表示大整数，不支持浮点数。
- 操作方式：
  - Number: 类型可以进行 +, -, *, / 等操作，不过在超大数值运算时精度可能会有损失。
  - BigInt: 类型主要用于整数操作，这样的运算不会出现精度损失，但是需要使用 BigInt 特有的运算符和方法。
- 表示方式：
  - Number: 常规表示法，如 42 或 3.14。
  - BigInt: 整数后添加 n，如 9007199254740991n。也可以使用 BigInt()。
- 性能考量: 
  - 操作 BigInt 一般比操作小范围的 Number 更慢，因为它需要处理更多位数的计算。
- 类型转换:
  - Number => BigInt: BigInt(number) 小数部分会被截取掉
  - BigInt => Number: Number(bigInt) 可能引起溢出和精度丢失
- API 支持:
  - Number 是 JavaScript 中默认的数值类型，有广泛的内置运算支持
  - BigInt 引入于 ECMAScript 2020（ES11），需要较新的浏览器版本支持

### 什么是 JavaScript 的尾调用? 使用尾调用有什么好处 ?
#### 含义
尾调用是指函数内部的最后一个操作是调用另一个函数的情况。
在 JavaScript 中，当一个函数调用发生在另一个函数的尾部（即调用结束后直接返回其结果，而无需进一步操作）时，这种调用称为尾调用。
#### 好处
使用尾调用的主要好处在于其对栈内存的优化。
通常情况下，每一个函数调用都会在栈内存中占据一个新的框架（frame），直到函数执行完成。
尾调用不需要保留当前函数的执行上下文，直接复用当前的栈帧，使递归操作更加高效，避免栈溢出（stack overflow）的风险，从而节省内存开销。
#### 补充
- 尾调用优化（Tail Call Optimization，TCO）：
并非所有的 JavaScript 环境都支持尾调用优化。
例如，某些现代浏览器和 Node.js 在严格模式下才会执行优化。
- 尾递归（Tail Recursion）:
尾递归是尾调用的一种特殊形式，指的是在递归函数中，递归调用是函数的最后一个操作。
因为尾递归可以直接复用当前的栈帧，所以在处理深度递归时，尾递归能显著减少栈内存的使用量。
```js
// 非尾递归
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

// 尾递归
function factorialTail(n, acc = 1) {
  if (n === 1) return acc;
  return factorialTail(n - 1, n * acc);
}
```
- JavaScript 严格模式：
在 JavaScript 中，为了使尾调用优化生效，代码需要运行在严格模式（strict mode）下。
最简单的方法是在文件或函数的头部添加 "use strict" 指令
- 应用场景：
尾调用和尾递归特别适合解决那些包含大量迭代步骤的算法问题。
常见的场景包括计算阶乘、斐波那契数列、Hanoi 塔问题等。
通过将递归过程转化为尾递归，可以显著提高程序在处理大数据量时的性能表现。

### JavaScript 为什么要进行变量提升? 它导致了什么问题 ?
#### 变量提升原因
JavaScript进行变量提升（Hoisting）主要是由于其解释器的工作机制。
在解析阶段，JavaScript引擎会将所有的变量声明和函数声明提升到其所在作用域的顶部，这样就可以在声明之前使用这些变量。
不过需要注意的是，只有声明会被提升，初始化不会被提升。
#### 问题
- 潜在的bug难以察觉。例如，使用一个未经初始化的变量可能导致不可预测的行为。
- 代码的可读性和可维护性降低。因为阅读代码的人可能误解变量的实际作用范围和生命周期。
#### 如何避免问题
- 始终在使用变量之前进行声明和初始化。
- 使用 let 和 const 代替 var，因为它们不会在块作用域内被提升。
- 养成良好的代码组织和注释习惯，确保代码可读性。
#### 补充
```js
// 1、如何提升
// 在JavaScript内部，变量和函数声明会在代码的执行阶段之前被提前处理。例如，以下代码：
console.log(a); // undefined
var a = 5;
// 实际相当于
var a;
console.log(a); // undefined 
a = 5;
// 这解释了为什么控制台输出undefined而不是ReferenceError: a is not defined

// 2、函数提升与变量提升的区别
// 函数声明会被完全提升到顶部，可以在声明之前调用：
console.log(sayHi()); // "Hi"
function sayHi() {
  return "Hi";
}
// 而函数表达式则不会被提升，它们遵循变量提升的规则：
console.log(sayHello); // undefined
var sayHello = function() {
  return "Hello";
}
console.log(sayHello()); // "Hello"

// 3、块级作用域与提升
// 在ES6之前，JavaScript只有全局作用域和函数作用域，变量提升在这两个作用域内操作。
// 而在ES6中，引入了块级作用域（由let和const定义），块级作用域内的变量不会被提升到块外部。
{
  console.log(b); // ReferenceError
  let b = 10;
}
```

### 使用 let 全局声明变量，能通过 window 对象取到吗 ?
- 在 JavaScript 中，使用 let 声明的全局变量不能通过 window 对象直接访问。
- 与之相对的是使用 var 声明的全局变量和在最外层作用域中定义的函数，它们可以通过 window 对象访问。
```js
let globalLet = "This is a let variable";
var globalVar = "This is a var variable";
function globalFn() {
  return "This is a global function";
}
console.log(window.globalLet); // undefined
console.log(window.globalVar); // "This is a var variable"
console.log(window.globalFn);  // [Function: globalFn]
```
#### 补充
- 作用域和变量提升
let 和 const 声明的变量在块级作用域内有效，而 var 声明的变量在函数作用域或全局作用域内有效。
此外，变量提升发生在 var 声明的变量上，而 let 和 const 则不会。
不过，即使提升了，let 和 const 也会因 TDZ（Temporal Dead Zone，暂时性死区）的缘故不能在声明前使用。
- 全局对象（Global Object）与顶层作用域
虽然在浏览器环境中 window 对象是全局对象，但是在 let 和 const 引入之前，var 声明的变量和顶层（global scope）中的函数，都会被绑定到 window 对象上。
然而，ECMAScript 2015（ES6）规范引入 let 和 const，它们虽然还是声明全局变量，但是不再绑定到 window 对象，这改善了全局变量污染的问题。
- 模块化和ES6
ES6 模块系统更进一步封装作用域，以import和export指令引入和输出模块内容，进一步减少全局变量污染。
例如，在模块文件里声明的变量和函数不会成为 window 对象属性，这是因为模块会自动遵循一种更严格的作用域规则。
- TDZ（Temporal Dead Zone）详解
TDZ 指的是在 let 和 const 声明变量之前，该变量是不可访问的，虽然在代码运行到此位置时，变量已经存在了。TDZ 的出现是为了防止变量声明前被使用带来的意外错误。

### let、const 和 var 的区别是什么 ?
- 作用域：
  - var 在函数作用域内有效，并且能在函数外被访问（如果定义在全局作用域）。
  - let 和 const 在块级作用域（如花括号 {} 内）有效。
- 重新赋值：
  - var 可以重新赋值和重新声明。
  - let 可以重新赋值但不能重新声明。
  - const 既不能重新赋值，也不能重新声明。定义时必须初始化。
- 提升（Hoisting）：
  - var 会被提升到其作用域的顶部，但不会初始化。
  - let 和 const 也会被提升到作用域的顶部，但在初始化之前不能被访问（称为"暂时性死区"）。
#### 补充
- 全局对象属性：
在全局作用域下，用 var 声明的变量会成为全局对象的属性。
例如，在浏览器环境中，var 声明的变量会成为 window 对象的属性。
但是 let 和 const 不会。
- 块级作用域与变量泄漏：
使用 var 的变量在 for 循环中的表现可能会导致意外错误，因为 var 没有块级作用域，且循环变量会在全局或函数作用域内共享。
使用 let 可以确保每次迭代都有一个新的绑定，以便解决这个问题。
- 暂时性死区：
暂时性死区是指在变量声明之前访问变量会导致引用错误，这对于 let 和 const 变量来说都是成立的。
这其实是一个非常有用的特性，可以防止因变量提升带来的潜在错误。
- 最佳实践：
使用 const 声明那些不会改变的变量是个好习惯，可以强调代码的不可变性。
只有在明确需要重新赋值的情况下使用 let。
在现代 JavaScript 编程中，几乎不会再用到 var 了，因为 let 和 const 能更好地处理作用域和提升问题。

### 说说你对 JS 作用域的理解 ?
#### 含义
作用域，其实就是一个变量或函数在代码中的可访问范围。
#### 分类
- 全局作用域：
  - 定义在所有函数体以及其他代码块之外的变量，称为全局变量。
  - 它们在脚本的任何地方都是可访问的。
- 局部作用域：
  - 局部变量定义在函数内或代码块内（如 if、for 块），它们只能在函数内或代码块内访问。
  - 局部作用域又可细分为函数作用域和块作用域。
  - 函数作用域：
    - 只在函数内部可见的变量，这种作用域在早期的 JavaScript 中非常常见。
  - 块作用域：
    - ES6 引入的 let 和 const 关键字，使得可以在块级代码（类似 {}）内部定义变量，即所谓的块作用域。
#### 补充
- 提升（Hoisting）：
  - 发生在变量声明和函数声明上，旨在解释为什么即使在声明之前使用变量也不会报错。
  - 变量提升是指不论变量在代码中的位置，它们会被提升到代码的顶部进行声明，
  - 而函数提升不仅是声明，它会把整个函数提升到顶部。
- 作用域链：
  - 当查找一个变量时，JavaScript 引擎会首先在当前作用域中查找，
  - 如果未找到，它会沿着作用域链向上查找，直到全局作用域。
  - 如果还未找到，则返回 undefined。
- 闭包（Closure）：
  - 函数内定义的函数能够访问外部函数的变量，这就是闭包。
  - 它是一种特殊的作用域情况，能让我们创建私有变量和函数。
- 立即执行函数表达式（IIFE）：
  - 一种常见的技术，通过定义和立即调用一个匿名函数，创建一个新的作用域，从而保护内部变量不受外部干扰。
  - 同时它也会避免全局变量污染的问题。
- 严格模式（Strict Mode）：
  - 严格模式扩展了 ECMAScript 3 的语法和语义范围，使 JavaScript 在更严格的条件下执行，有助于更好地调试和提升代码的安全性。
- 模块化（Modules）：
  - 现代 JavaScript 越来越依赖模块化，通过 import 和 export 关键字，可以在不同模块之间共享代码，避免作用域污染，并且更好地组织代码。

### 什么是 JavaScript 的临时性死区 ?
#### 含义
JavaScript 中的临时性死区（Temporal Dead Zone, TDZ）是指在代码块中使用 let 或 const 变量之前，这些变量暂时无法访问的区域。
虽然在语法上已经声明了这些变量，但如果尝试在声明之前使用它们，就会抛出 ReferenceError 错误。
#### 作用
TDZ 确保开发者不会在变量被初始化之前使用它们，从而避免了很多潜在的错误，确保代码的真实性和可靠性。
#### 补充
```js
// 1、临时性死区
// 这里发生了临时性死区
console.log(a); // ReferenceError: a is not defined
let a = 10;

// 2、Hoisting（变量提升）
// var 变量的一个特点是变量提升，它的声明会被提升到函数或全局作用域的顶部。
// 不过，变量声明虽然提升，但不会初始化。
// 因此，在初始化之前使用变量会得到 undefined。
// 与 var 不同，let 和 const 不会被提升，这也是 TDZ 的基本原则

// 变量提升的例子
console.log(b); // undefined
var b = 20;

// TDZ 的例子
console.log(c); // ReferenceError: c is not defined
let c = 30;

// 3、块级作用域（Block Scope）
// let 和 const 引入了块级作用域，这使得变量只能在其声明的代码块{}内有效。
// 同样，这些变量也在 TDZ 中，直到执行到声明语句为止
{
  console.log(d); // ReferenceError: d is not defined
  let d = 40;
}

// 4、const 的特点
// 与 let 类似，const 声明的变量也有 TDZ，并且要注意的是，const 声明的变量一旦初始化就不允许重新赋值。
// 如果需要声明一个不变的常量，const 是一个很好的选择
{
  console.log(e); // ReferenceError: e is not defined
  const e = 50;
  e = 60; // TypeError: Assignment to constant variable.
}
```

### JavaScript 事件冒泡和捕获的区别是什么 ? 默认是冒泡还是捕获 ?
- JavaScript 中的事件处理模型主要分为两种：事件冒泡和事件捕获。
- 事件冒泡: 事件先从目标元素开始，一层一层向上传播到根元素
- 事件捕获: 事件从根元素一层一层向下传播到目标元素
- 默认的事件传递机制是事件冒泡。
#### 补充
```js
// 1、事件流阶段
// 捕获阶段：从 document 根对象往目标元素传播。
// 目标阶段：事件到达目标元素处。
// 冒泡阶段：从目标元素往 document 根对象传播。

// 2、添加事件监听器
// 通过 addEventListener 方法，第三个参数来指定是否在捕获阶段触发事件
// example for event capturing
element.addEventListener('click', handleClick, true); // 传 true 表示在捕获阶段执行
// example for event bubbling
element.addEventListener('click', handleClick, false); // 传 false 或缺省表示在冒泡阶段执行

// 3、事件传播停止
// 在某些情况下，可能需要中止事件的传播，如阻止冒泡或者捕获
event.stopPropagation();

// 4、事件委托
// 事件冒泡机制允许我们使用事件委托（Event Delegation）技术，以减少事件监听器的数量，从而提高性能。
// 例如，把所有子元素的点击事件委托给父元素处理
parentElement.addEventListener('click', function(event) {
  if(event.target.matches('.childClass')) {
    // 子元素被点击的逻辑处理
  }
});

// 5、浏览器兼容性
// 现代浏览器普遍支持事件冒泡及捕获模型，但在使用过程中，可能还是要考虑到一些老旧浏览器（如 IE 8）的问题。
// 这些浏览器可能不完全支持 addEventListener，而是使用 attachEvent。
// 为兼容这些老旧浏览器，通常采用一些 polyfill 类库或者针对性地写兼容代码。
```

### 什么是 JavaScript 的事件代理 ? 
#### 含义
- 事件代理（Event Delegation）是 JavaScript 中处理事件的一种优化技术。
- 其核心思想是利用事件冒泡机制，将子元素的事件委托到父元素，从而通过一个事件处理程序来管理多个子元素的事件。

- 如果我们有多个子元素都需要响应某个事件（比如点击），与其在每个子元素上绑定事件处理器，不如在它们的父元素上绑定一个事件处理器。
- 当子元素触发事件时，事件会冒泡传递到父元素，由父元素的事件处理程序来处理这个事件。
#### 使用场景
```js
document.getElementById("parent-ul").addEventListener("click", function(event) {
  if (event.target && event.target.nodeName === "LI") {
    console.log("List item", event.target.textContent, "was clicked.");
  }
});
```
#### 好处
- 提高性能：通过减少事件处理程序的数量，降低内存消耗和执行开销。
- 简化代码：统一管理子元素的事件处理逻辑，使代码更易于维护。
- 动态元素支持：事件代理可以处理新添加到 DOM 中的子元素，而不需要额外的事件绑定操作。
#### 注意事项
尽管事件代理带来了许多好处，但在某些情况下需要小心使用，例如当子元素很多或需要精确定位某些复杂事件时，可能会带来额外的复杂性。

### 什么是 JavaScript 的事件流 ?
#### 含义
JavaScript的事件流指的是当事件在网页中发生时，事件如何在文档对象模型 (DOM) 层次结构中传播的行为和过程。
#### 过程
事件流主要包括两个过程：事件捕获（Event Capturing）和事件冒泡（Event Bubbling）。
- 事件捕获：从最外层的祖先元素开始，逐层向下传递事件，直到目标元素。
- 事件冒泡：事件从目标元素开始，逐层向上传递到最外层的祖先元素。
#### 阶段
- 事件捕获阶段: 事件从顶层元素开始向下传播
  - 这个阶段是从外到内的过程。浏览器首先会检查是否在祖先元素（html、body 等）上绑定了事件监听器，如果有的话，会调用这些监听器。
  - 捕获阶段历经的路径是从 document 根元素到目标元素，不触及目标元素本身。
- 目标阶段: 事件到达目标元素
  - 当事件到达目标元素时，浏览器会查看目标元素自身是否绑定了相应的事件监听器。
  - 在目标元素，这个阶段允许监听器通过 event.stopPropagation()方法来阻止事件继续传播到冒泡阶段。
- 事件冒泡阶段: 事件从目标元素向上传播
  - 完成目标阶段后，事件随后由目标元素向上层返回，逐层向上执行绑定的事件监听器。
  - 开发人员可以通过 event.stopPropagation() 方法在任何一个阶段停止事件的传播，实现对事件流的控制。
#### 实际应用
在实际开发中，了解和掌握事件捕获和事件冒泡的机制，有助于更好地控制事件的传播，实现如事件委托等高效处理事件的方式。
#### 事件委托
- 由于事件冒泡的特点，我们可以在父元素上绑定事件监听器，而不需要在每个子元素上分别绑定。这种方式称为事件委托，能提高性能和代码可维护性。
- 例如，考虑一个动态生成的列表，可以在父元素上统一处理点击事件，而不是给每个列表项绑定监听器。
#### 兼容性问题
- 虽然现代浏览器都支持事件捕获和事件冒泡，但在早期的 IE 浏览器中，事件流的实现有所不同。
- 现代开发中主要依赖 W3C 标准事件流模型，但在需要支持老旧浏览器时仍需考虑不同的实现方式。

### 什么是 JavaScript 的事件轮询机制 ?
#### 含义
- JavaScript 的事件轮询机制，通常被称为“事件循环”（Event Loop），是 JavaScript 用来处理异步操作，确保非阻塞执行的一种机制。
- 简而言之，事件循环负责协调执行代码、收集和处理事件以及执行队列中的子任务。
#### 动机
- JavaScript 是单线程语言，这意味着其在同一时间只能执行一个任务，
- 而事件循环机制则允许 JavaScript 通过分配时间段来处理异步任务，从而表现出类似多线程的效果。
#### 代码示例
```js
console.log('1');
setTimeout(() => {
  console.log('2');
}, 1000);
console.log('3');
new Promise((resolve) => {
  resolve();
}).then(() => {
  console.log('4');
}).then(() => {
  console.log('5');
});
console.log('6');
// 执行结果  
// 执行同步代码 => 1 3 6
// 处理微任务队列 => 4 5
// 宏任务队列中的回调函数 => 2
```
#### 补充
- 调用栈（Call Stack）：
  - 调用栈是一个记录函数调用的机制，函数被调用时会被压入栈顶，执行完成后被弹出。
  - 所有同步任务在调用栈中按顺序执行。
- 任务队列（Task Queue）：
  - 任务队列包含了所有异步任务的回调函数，这些回调函数按照事件触发的顺序被放入任务队列。
  - 任务队列又可以分为宏任务队列和微任务队列。
  - 宏任务（Macro Task）：
    - 宏任务包括 script、setTimeout、setInterval、I/O 等。
    - 每次事件循环首先检查并执行一个宏任务。
  - 微任务（Micro Task）：
    - 微任务包括 Promise、process.nextTick（Node.js 中）等。
    - 微任务在当前宏任务处理完后立即执行，优先级高于下一个宏任务。
- 事件循环（Event Loop）：
  - 事件循环的主要工作是检查
    - 调用栈是否为空
    - 如果为空，则检查任务队列
    - 如果有任务，则将其压入调用栈执行
    - 如果栈中没有同步任务，而任务队列中有任务，则依次执行这些任务。
  - 这个过程会不断重复，形成“事件循环”。
#### 延伸话题
理解 JavaScript 的事件循环对于解决一些实际开发中的异步问题非常重要。
例如，防止阻塞 UI 渲染、优化长时间任务的性能、正确合理地使用 async/await 等异步编程方式，在了解事件轮询机制之后都会游刃有余。

### 什么是 JavaScript 的原型链 ?
- JavaScript 的原型链是一个机制，通过它可以实现对象间的属性继承。
- 当访问一个对象的属性时，JavaScript 引擎首先会看这个属性是否存在于对象自身。
- 如果不存在，那么它会沿着这个对象的原型链向上查找，直到找到该属性或到达原型链的顶端（通常是 Object.prototype），在这种情况下返回 undefined。
#### 补充
##### 原型（Prototype）
- 每个 JavaScript 对象都有一个内部属性叫做 [[Prototype]]，这通常可以通过 __proto__ 来访问。
- 这个 [[Prototype]] 指向另一个对象，从而形成了所谓的原型链。
##### 构造函数与原型
```js
// 在 JavaScript 中，函数都有一个 prototype 属性，
// 这个属性指向一个对象，
// 这个对象的作用是当使用 new 操作符创建一个实例时，作为该实例的原型。
function Person(name) {
  this.name = name;
}
Person.prototype.sayHello = function() {
  console.log('Hello, ' + this.name);
};
let alice = new Person('Alice');
alice.sayHello(); // 输出 "Hello, Alice"
```
##### 继承与原型链
- JavaScript 通过原型链实现继承，即一个对象可以继承另一个对象的属性和方法。
- 在上面的例子中，alice 继承了 Person.prototype 上的方法 sayHello。
##### Object.prototype
- JavaScript 中所有对象最终都可以追溯到 Object.prototype。
- 这是原型链的顶端，也是所有对象最终会继承的原型对象。
- Object.prototype 上的方法比如 toString()、hasOwnProperty() 等都可以在所有对象上调用。
##### class 语法糖
```js
// ES5 的原型继承代码，较为繁琐的。
// 为了简化这一过程，ES6 引入了 class 语法糖，
// 其实质基于原型的继承。
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(this.name + ' makes a noise.');
  }
}

class Dog extends Animal {
  speak() {
    console.log(this.name + ' barks.');
  }
}

let dog = new Dog('Rover');
dog.speak(); // 输出 "Rover barks."

```
##### 对于原型链的调试
在调试 JavaScript 代码时，我们可以使用 console.log 或开发者工具来查看对象的 __proto__ 属性，
从而了解它们在原型链中的位置。

### 什么是 JavaScript 的原型修改、原型重写 ?
#### 含义
- JavaScript 的原型系统是这门语言的核心特性之一。
- 每个 JavaScript 对象都有一个原型对象，它从中继承方法和属性。
- 当我们谈论 "原型修改" 和 "原型重写" 时，我们实际是在讨论两种操作
- 原型修改 (Prototype Modification)
  - 更改原型对象的内容，例如添加或删除方法或属性。
- 原型重写 (Prototype Reassignment)
  - 将对象的原型更改为一个全新的对象。
#### 代码示例
```js
// 1、原型修改 (Prototype Modification)
function Person(name) {
  this.name = name;
}
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};
const alice = new Person('Alice');
alice.sayHello(); // 输出: Hello, my name is Alice

// 2、原型重写 (Prototype Reassignment)
function Person(name) {
  this.name = name;
}
// 原始原型
Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};
// 新的原型对象
Person.prototype = {
  greet: function() {
    console.log(`Greetings, my name is ${this.name}`);
  }
};
const bob = new Person('Bob');
bob.greet(); // 输出: Greetings, my name is Bob
// 此时bob不再具有sayHello()
```
#### 注意事项
- 原型链（Prototype Chain）：
  - JavaScript 对象可以形成原型链，从而实现多层继承。
- 性能问题：
  - 频繁修改原型可能会带来性能问题，特别是在高性能或实时应用中。
- 实际运用：
  - 在实际开发中，经常使用原型继承增加方法和共享属性，但较少使用原型重写，因为它可能会导致维护上的困惑。
- 在复杂的代码库中，合理使用原型系统可以带来极大的灵活性和复用性，但也需要注意代码的可读性和维护性。如果使用得当，它可以让代码更简洁，更易读。

### JavaScript 的原型链指向什么 ?
- 在 JavaScript 中，所有对象都是通过原型链（prototype chain）来实现继承的。
- 简单来说，原型链是一种让对象共享属性和方法的机制。
- 每个对象都有一个内部链接（proto），指向其构造函数的原型对象（prototype）。 
- 原型对象本身也可以有一个 proto，这样一直链接下去，形成一个链状结构，直到指向 null 为止。
#### JavaScript 中原型链的实现和意义
```js
// 1、对象的创建与原型链
// 每当我们创建一个对象（无论是通过对象字面量还是通过构造函数），
// 该对象会自动获得一个 proto 属性，指向其构造函数的 prototype。
function Person(name) {
  this.name = name;
}
const student = new Person('Alex');
console.log(student.__proto__ === Person.prototype);  // true

// 2、原型链查询机制
// JavaScript 会通过原型链来查找属性或方法。
// 假设我们要访问对象 student 的 name 属性，
// 它首先会在 student 对象自身查找，
// 如果找不到，该查找操作会沿着 proto 链条继续向上，直到找到为止，
// 或者到链条末尾（即 null）停止。

// 3、原型对象的原型
// 由于原型对象本身也是一个对象，它也有自己的 proto 属性。
// 一般情况下，函数的 prototype 对象的 proto 会指向 Object.prototype， 
// 而 Object.prototype 的 proto 则为 null。
console.log(Person.prototype.__proto__ === Object.prototype);  // true
console.log(Object.prototype.__proto__);  // null

// 4、Function 和 Object 的特殊关系
// 在 JavaScript 中，函数也是对象，因此 Function 的 proto 是 Function.prototype。
// 值得注意的是，Function.prototype 本身是一个函数，其 proto 指向 Object.prototype。 
// 这种相互指向的关系构成了 JavaScript 的原型链的基础。
console.log(Function.__proto__ === Function.prototype); // true
console.log(Function.prototype.__proto__ === Object.prototype); // true

// 5、原型链与继承
// 原型链是实现继承的一种重要方式。
// 例如，我们可以通过构造函数继承或原型继承来实现对象的属性和方法复用
function Animal(name) {
  this.name = name;
}
Animal.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
}
function Dog(name, breed) {
  Animal.call(this, name);
  this.breed = breed;
}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;
const dog = new Dog('Buddy', 'Labrador');
dog.sayHello();  // Hello, I'm Buddy
```

### JavaScript 原型链的终点是什么 ? 如何打印出原型链的终点 ?
- JavaScript 原型链的终点是null。
- 每个对象的原型（prototype）会往上追溯形成一个链条，最终这个链条会追溯到原型为null的对象，
- 而这个对象就是Object.prototype。
```js
function getPrototypeChainEnd(obj) {
  let current = obj;
  while (Object.getPrototypeOf(current) !== null) {
    current = Object.getPrototypeOf(current);
  }
  return current;
}
const obj = {};
console.log(getPrototypeChainEnd(obj)); // Object.prototype
console.log(Object.getPrototypeOf(Object.prototype)); // null
```
#### 补充
- 什么是原型链 ?
  - 每个JavaScript对象都有一个内部属性[[Prototype]]，可以通过Object.getPrototypeOf(obj)或__proto__访问。
  - 这个原型对象也可以有自己的原型，如此层层递进，形成一个链条，即原型链。
- Object.prototype的特殊地位
  - 在这个链条最顶端的就是Object.prototype，它的原型是null，代表着原型链的终点。
  - 其他内置对象的原型，比如Array.prototype、Function.prototype等，实质上都指向Object.prototype, 最终都指向null。
- 如何理解继承 ?
  - 在JavaScript中，继承靠的是原型链。
  - 比如，当你访问一个对象的属性时，如果这个属性在对象自身不存在，JavaScript会沿着原型链向上查找，直到找到属性或到达链顶。
  - 如果沿途都找不到，最终会返回undefined
- ES6中的class如何对应原型链
```js
// 虽然ES6引入了class语法糖，但底层仍然是基于原型和原型链机制的。
// class声明仅仅让原型继承的书写方式更简洁清晰。
class Animal {}
class Dog extends Animal {}
const dog = new Dog();
console.log(Object.getPrototypeOf(dog)); // Dog.prototype
console.log(Object.getPrototypeOf(Dog.prototype)); // Animal.prototype
console.log(Object.getPrototypeOf(Animal.prototype)); // Object.prototype
// 原型链是JavaScript实现继承的核心机制，理解它不仅有助于掌握面向对象编程的精髓，也能更好地处理代码中的继承和属性查找问题。
```

### JavaScript 如何获得对象非原型链上的属性 ? 
```js
// 1、Object.keys() 方法
// Object.keys() 返回一个数组，元素是对象自身的可枚举属性的字符串名字。
// 仅包括对象自身的属性，不含继承自原型链的属性。

// 2、Object.getOwnPropertyNames() 方法
// Object.getOwnPropertyNames() 返回一个数组，包含的是对象自身的所有属性（包括不可枚举属性，但不包括 Symbol 属性）。
// 相比 Object.keys()，Object.getOwnPropertyNames() 更全面，但有时候并不需要。
const obj = {
  a: 1,
  b: 2,
  c: 3
};
const ownProps1 = Object.keys(obj); // 输出: ["a", "b", "c"]
console.log(ownProps1);
const ownProps2 = Object.getOwnPropertyNames(obj); // 输出: ["a", "b", "c"]
console.log(ownProps2);
```
#### 补充
- 对象自身属性与原型链属性的区别
  - 对象自身属性是直接定义在对象实例上的属性
  - 原型链属性是通过对象的原型（prototype）继承而来的属性
- 其他获取特定属性类型的方法
  - 使用 Object.getOwnPropertySymbols() 可以获取对象自身的 Symbol 属性
  - 使用 Reflect.ownKeys() 可以获取对象自身的所有属性，包括字符串和 Symbol 属性
  ```js
  const sym = Symbol('foo');
  const obj = {
    a: 1,
    [sym]: 2
  };
  const ownProps = Reflect.ownKeys(obj); // 输出: ["a", Symbol(foo)]
  console.log(ownProps);
  ```
- 应用场景
- 在项目开发中，有时需要遍历对象的属性来进行某些操作如深拷贝、数据筛选、序列化等，
- 这时候区分对象自身属性和原型链属性是非常必要的，可以避免把不需要的属性误操作。

### 什么是 JavaScript 的闭包 ? 有什么作用和使用场景 ?
#### 含义
- 闭包是指在 JavaScript 中，函数能够访问其词法作用域（定义时而不是执行时的作用域）中的变量。
- 即使该函数是在其定义的作用域之外执行的。
- 简单来说，闭包让你能够从外部访问一个函数内部的变量。
#### 实现原理
- 闭包是一个函数能够访问其外部声明的变量，即使在该函数在它的词法作用域之外被调用。
- 具体来说，闭包是由函数和其外部环境的组合。
  - 当一个函数在另一个函数内部被定义时，内部函数可以访问外部函数的变量，这种现象被称为闭包。
#### 主要作用
- 创建私有变量和方法：
  - 闭包可以帮助我们模拟私有变量，从而增加代码的可维护性和安全性。
- 保存状态：
  - 可以用来保持某个函数执行上下文中的状态。
- 回调函数：
  - 在异步编程中，闭包用于传递回调函数并保留执行时的环境。
#### 使用场景
- 数据封装：
  - 比如模块模式，隐藏内部实现，只暴露需要的接口。
- 记忆化函数：
  - 缓存函数的运算结果，从而提高性能。
- 事件处理器：
  - 闭包有助于避免全局变量污染，并且能够保持事件处理过程中需要的状态。
#### 代码示例
```js
// 1、模拟私有变量和方法
// 闭包通常用来创建私有变量和方法。
// 在 JavaScript 中，我们没有真正的私有成员，但我们可以通过闭包来模拟这一点。
function Counter() {
  let count = 0;
  return {
    increment: function() {
      count ++;
      return count;
    },
    decrement: function() {
      count --;
      return count;
    }
  };
}
const myCounter = Counter();
console.log(myCounter.increment()); // 1
console.log(myCounter.decrement()); // 0
// 在这个例子中，count 变量对外部是完全隐藏的，只有通过 increment 和 decrement 方法才能访问和修改它。

// 2、保存状态（创建函数工厂）
// 闭包允许我们在函数执行的后续调用中保存状态。
function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}
const add5 = makeAdder(5);  // x => 5  add5 => (y) { return x + y }
console.log(add5(2));  // 7
console.log(add5(10)); // 15

// 3、回调函数和异步编程
// 在许多异步编程中
// 比如事件监听或计时器函数，闭包可以帮助我们在回调函数中保持执行时的环境。
function setup() {
  let name = "Mozilla";
  function displayName() {
    alert(name);
  }
  return displayName;
}
const myFunc = setup();
myFunc(); // Alerts 'Mozilla'
// displayName 函数在定义它的作用域内引用了 name 变量
// 而当 setup 函数返回之后，displayName 仍然能够访问 name。
function fetchData(url) {
  let cachedData;
  return function(callback) {
    if (cachedData) {
      callback(cachedData);
    } else {
      fetch(url)
        .then(response => response.json())
        .then(data => {
          cachedData = data;
          callback(data);
        });
    }
  };
}
const getData = fetchData('https://api.example.com/data');
getData(data => {
  console.log(data); // 输出获取到的数据
});
// 只在第一次调用时进行网络请求，而后续调用直接返回缓存中的数据。

// 4、数据封装与模块模式
// 闭包在现代 JavaScript 模块开发中也很有用。
// 通过闭包，我们可以创建模块，隐藏内部实现，只暴露必要的接口。
const Module = (function() {
  let privateVariable = "I am private";
  function privateMethod() {
    console.log(privateVariable);
  }
  return {
    publicMethod: function() {
      privateMethod();
    }
  };
})();
Module.publicMethod(); // Logs 'I am private'
// 这里利用闭包创建了一个模块 Module，其中的 privateVariable 和 privateMethod 是私有的，仅能通过 publicMethod 访问。
```

### 说说你对 JavaScript 作用域、作用域链的理解 ?
- 在 JavaScript 中，作用域是指代码在某个特定范围内能够访问变量和函数的集合。
- 主要有两类作用域：全局作用域和局部作用域（包括函数作用域和块级作用域）。
  - 全局作用域：在浏览器环境中，最外层的作用域为全局作用域，所有在全局作用域中声明的变量和函数都可以在任何地方访问到。
  - 局部作用域：
    - 函数作用域：在函数内部声明的变量只在该函数内部可见。
    - 块级作用域：用 let 和 const 声明的变量，其作用域只在定义所在的代码块内（如 {} 大括号内）。

- 作用域链则是当变量在当前作用域中无法找到时，JavaScript 会一层一层地向外查找，直到找到变量或到达全局作用域。
- 作用域链：
  - 当在某个作用域中引用一个变量时，JavaScript 引擎会尝试先在当前作用域查找，
  - 如果未找到，则会沿着作用域链向外查找，直到全局作用域。
  - 未找到时会报 ReferenceError。

- 作用域和作用域链在 JavaScript 编程中扮演着重要角色，有助于组织代码，避免冲突。
#### 补充
- 词法作用域：
  - 词法作用域（Lexical Scope）指的是作用域在代码书写时就已经确定了，而不是在运行时确定。
  - 在 JavaScript 中，作用域是基于程序的书写结构来决定的，而非调用关系。
- 变量提升：
  - JavaScript 的变量和函数声明在编译阶段会被“提升”到所属作用域的顶端，但 let 和 const 声明的变量不会被提升。
  - 变量提升会导致一些令人困惑的行为，因此建议尽量在作用域的顶部声明变量。
- 闭包：
  - 闭包是指函数内部的变量即使在函数调用结束后仍然可以被外部函数访问。
  - 闭包依赖于作用域链，它能够看见自己作用域中的变量以及在外部作用域中的变量。这是因为函数保存了对其词法作用域的引用。
- 块级作用域：
  - ES6 引入了块级作用域，可以使用 let 和 const 来定义块级作用域变量，在 {} 代码块内才有效，这样更好地控制变量的生命周期和作用域范围。
- 立即执行函数表达式（IIFE）：
  - IIFE 是一种常见的 JavaScript 编程模式，通过立即调用匿名函数来创建一个新的作用域，从而避免污染全局作用域，用来封装独立的代码模块。

### 什么是 JavaScript 的执行上下文 ?
- JavaScript 的执行上下文（Execution Context）是指 JavaScript 代码在执行时所处的环境。
- 执行上下文决定了代码在运行时所能访问的变量、函数、以及如何调用，其中包含了变量对象、作用域链和 this 值。
#### 补充
- 执行上下文的类型
  - 全局执行上下文：
    - 这就是默认的执行上下文，当 JavaScript 代码开始执行时，全局执行上下文会首先被创建。
    - 在浏览器环境中，全局对象是 window，在 Node.js 环境下，全局对象是 global。
  - 函数执行上下文：
    - 每当调用一个函数时，都会创建一个新的函数执行上下文。
    - 每个函数调用都有自己的上下文，并且它们可以嵌套。
  - Eval 执行上下文：
    - 这种上下文是由 eval 函数引发的，几乎没有人会建议使用它，因为它会使得代码难以维护和调试。
- 执行上下文的组件
  - 变量对象（Variable Object, VO）：
    - 包含了函数的所有形参、内部变量和函数声明。对于函数上下文来说，它被称为活动对象（Activation Object, AO）。
  - 作用域链（Scope Chain）：
    - 在执行上下文中，作用域链用来解析变量，它包含当前上下文的变量对象以及所有父级（词法）上下文的变量对象。
  - this 值：
    - 在不同的执行上下文中 this 的值不同。
    - 在全局上下文中，this 指向全局对象；
    - 在函数上下文中，this 的值取决于函数的调用方式（比如作为对象的方法调用时 this 指向对象）。
- 执行上下文的生命周期
  - 创建阶段：
    - 创建变量对象：包括函数参数，函数声明，变量声明（但是不会立刻赋值）。
    - 创建作用域链：形成一个作用域链，并将其与当前执行上下文关联。
    - 确定 this 值：根据调用位置，确定当前上下文的 this 值。
  - 执行阶段：
    - 变量分配：变量赋值和函数引用开始执行。
    - 执行代码：根据代码逻辑逐行执行，完成整个执行过程。

### 说说你对 JavaScript 中 this 的理解 ? 指向什么 ?
- “this” 是 JavaScript 中一个非常重要且有时容易混淆的关键字。
- 简单来说，this 的值是在函数被调用时决定的，而不是在函数定义时决定的。
- 它取决于函数的调用位置和方式，可以指向不同的对象。

- 在全局作用域中，this 指向全局对象（在浏览器中为 window）。
- 在对象方法中，this 指向调用方法的对象。
- 在构造函数中，this 指向新创建的实例对象。
- 在事件处理函数中，this 指向绑定事件的 DOM 元素。
- 在箭头函数中，this 是词法绑定的，它与包围它的非箭头函数的 this 值相同。

#### 补充
```js
// 1、全局作用域
// 在非严格模式下，全局范围内的 this 默认指向全局对象 window。
console.log(this === window); // true

// 2、函数调用
// 直接调用一个函数（非严格模式），this 指向全局对象 window。
function myFunction() {         
  console.log(this); // window     
}
myFunction(); 

// 3、对象方法调用
// 当函数作为对象的方法被调用时，this 指向该对象。
const obj = {         
  name: "Alice",         
  getName: function() {             
    console.log(this.name);  // Alice  
  }     
};
obj.getName();

// 4、构造函数调用
// 在构造函数中，this 指向新创建的实例对象。
function Person(name) {
  this.name = name;
}
const person = new Person("Bob");
console.log(person.name); // Bob

// 5、事件处理函数
// 在事件处理函数中，this 指向绑定事件的 DOM 元素。
const button = document.createElement('button');
button.addEventListener('click', function() {
 console.log(this); // <button> element
});

// 6、箭头函数
// 箭头函数不会创建自己的 this，它会捕获其所在上下文的 this 值。
const obj = {
  name: "Charlie",
  getName: function() {
    const arrowFunc = () => console.log(this.name);
    arrowFunc(); // Charlie
  }
};
obj.getName

// 7、严格模式（"use strict"）
// 在严格模式下，顶级上下文中的 this 是 undefined，而不是 window。
"use strict";
function myStrictFunction() {         
  console.log(this); // undefined
}
myStrictFunction(); 

// 8、显式绑定
// 使用 call、apply、bind 可以显式绑定 this。
function greet() {
  console.log(this.name);
}     
const john = { name: "John" };
greet.call(john);  // John
```

### JavaScript 中 call、apply 及 bind 函数有什么区别 ?
```js
// 1、call: 
// call 方法可以用来调用一个函数，并且显式地指定其 this 值和需要额外传入的参数。
// call 的参数是按顺序单独传递的。
function greet(message) {
  console.log(`${message}, ${this.name}`);
}
const person = { name: 'Alice' };
greet.call(person, 'Hello'); // 输出: Hello, Alice

// 2、apply: 
// apply 方法和 call 类似，但是它接受的是一个参数数组或类数组对象（如 arguments）来作为参数传递，适用于需要将参数批量传递的情景。
function greet(message1, message2) {
  console.log(`${message1} and ${message2}, ${this.name}`);
}
const person = { name: 'Bob' };
greet.apply(person, ['Hello', 'Goodbye']); // 输出: Hello and Goodbye, Bob

// 3、bind: 
// bind 方法返回一个新函数，且该新函数的 this 值永久地被指定为传入的值。
// 不同于 call 和 apply 直接执行函数，bind 只是创建新函数，需要手动调用。
function greet() {
  console.log(`Hello, ${this.name}`);
}
const person = { name: 'Charlie' };
const boundGreet = greet.bind(person);
boundGreet(); // 输出: Hello, Charlie

```

### 如何实现 call、apply 及 bind 函数 ?
```js
// call：接收若干个参数，第一个参数是新 this 绑定对象，后续参数是函数的实际参数。
Function.prototype.myCall = function (context, ...args) {
  context = context || globalThis;
  const fnSymbol = Symbol('fn');
  context[fnSymbol] = this;
  const result = context[fnSymbol](...args);
  delete context[fnSymbol];
  return result;
};
// apply：跟 call 很像，但第二个参数是数组，作为函数的参数传递。
Function.prototype.myApply = function (context, args) {
  context = context || globalThis;
  const fnSymbol = Symbol('fn');
  context[fnSymbol] = this;
  const result = Array.isArray(args) ? context[fnSymbol](...args) : context[fnSymbol]();
  delete context[fnSymbol];
  return result;
};
// bind：返回一个新函数，这个新函数在执行时 this 被指定为第一个参数，并接收其余参数。
Function.prototype.myBind = function (context, ...args) {
  const fn = this;
  return function (...newArgs) {
    return fn.apply(context, args.concat(newArgs));
  };
};
```
#### 补充
- 为什么要用 Symbol
  - 使用 Symbol 作为临时的函数属性名，目的是为了避免与上下文对象中的其他属性冲突。
  - Symbol 生成的唯一属性名保证不会覆盖已有的属性。
- call 和 apply 的区别
  - 更适合参数固定的场景，参数一一列出；
  - apply 更适合参数不定或存在参数数组的场景，可以直接传递数组而不需要逐个展开。
- bind 的实际应用
bind 在事件处理、回调函数中非常有用，尤其当需要保留特定的上下文环境时：
  - 在 React 组件中绑定方法时常用this.handleClick = this.handleClick.bind(this)
  - 与闭包和高阶函数结合使用，可以提前绑定部分参数，形成偏函数（Partial Function）
- 性能注意点
  - 在高性能场景下，过度使用 call、apply 会造成一定的性能开销。
  - 可以采用函数柯里化、缓存等优化方法减小影响，特别是在循环或递归中更需谨慎使用。
- ES6 和新特性
  - 借助 ES6 的箭头函数（Arrow Function）可以避免手动绑定 this，但需注意箭头函数this的绑定在定义时就已经确定，不能通过 call、apply 或 bind 改变。

### JavaScript 中连续多次调用 bind 函数，最终 this 指向什么 ?
```js
function foo() {
  console.log(this.name);
}
const obj1 = { name: 'Alice' };
const obj2 = { name: 'Bob' };
const boundFoo1 = foo.bind(obj1);
const boundFoo2 = boundFoo1.bind(obj2);
boundFoo2(); // 输出: 'Alice'

// 如果对一个函数多次调用 bind 方法
// 那么最终的 this 指向的是多次调用 bind 时的第一个 this 绑定对象
// 后续的 bind 调用不会改变这个 this 绑定。
```
#### 补充
```js
// 1、bind 方法的原理
// bind 方法会创建一个新的函数（被称为绑定函数），
// 对这个新函数调用时，它的 this 被设置为 bind 的第一个参数，而不论这个函数是如何调用的。
// 后续的 bind 调用是对新函数进一步嵌套，
// 由于第一次绑定后绑定函数已经形成闭包，this 永远指向初次绑定的对象，其它绑定无效。
Function.prototype.bind = function(context) {
  var self = this;
  return function() {
    return self.apply(context, arguments);
  };
};

// 2、bind 的多次调用的常见误解
// 许多人会错误地认为多次 bind 可以修改绑定对象，需要注意的是一旦第一次 bind 绑定了 this
// 接下来的 bind 调用是无效的。我们可以通过实际操作进行验证和区分。

// 3、调用上下文与闭包
// 这个问题的本质是对 JavaScript 调用上下文和闭包原理的考察。
// bind 方法利用了闭包特性来保存首次绑定的 this 引用，从而锁定了调用时的上下文。
// 在实际项目中，理解这些原理也有助于写出优雅、性能优越的代码。

// 4、ES6 Arrow Functions
// 箭头函数中的 this 是词法绑定的，即它们的 this 取决于定义时的作用域，而不是调用时的作用域。
// 这与 bind 方法中的 this 绑定不同，箭头函数的 this 在定义时已经确定，无法在执行期间更改。
const arrowFunc = () => {
  console.log(this.name);
};
const obj3 = { name: 'Charlie' };
arrowFunc.bind(obj3)(); // 输出：undefined
```

### promise.all 和 promise.allsettled 函数有什么区别 ?
romise.all 和 Promise.allSettled 是 JavaScript 中处理多个异步操作的两种方法。
#### 主要区别
- Promise.all
  - 此方法接收一个 promise 对象数组，并返回一个新的 promise。
  - 当数组中所有 promise 都解决（resolve）时，返回的 promise 解决，并返回一个包含每个 promise 解决结果的数组。
  - 如果数组中的任何一个 promise 被拒绝（reject），返回的 promise 也会立即被拒绝，并返回拒绝的原因。
- Promise.allSettled
  - 此方法也接收一个 promise 对象数组，并返回一个新的 promise。
  - 无论数组中的 promise 是解决还是拒绝，返回的 promise 都会解决，并返回一个包含每个 promise 结果对象的数组，每个结果对象包含两种属性：status（"fulfilled" 或 "rejected"）和 value 或 reason。

- 总结来说
  - Promise.all 更适用于处理所有 promise 都需要成功的情况，
  - Promise.allSettled 更适用于需要知道每个 promise 结果的情况。
#### 代码示例
```js
// Promise.all 示例
const promise1 = Promise.resolve(3);
const promise2 = Promise.resolve(42);
const promise3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});
Promise.all([promise1, promise2, promise3]).then(values => {
  console.log(values); // [3, 42, "foo"]
}).catch(error => {
  console.error('Error:', error);
});

// Promise.allSettled 示例
const promise4 = Promise.resolve(3);
const promise5 = new Promise((resolve, reject) => {
  setTimeout(reject, 100, 'error');
});
const promise6 = Promise.resolve(42);
Promise.allSettled([promise4, promise5, promise6]).then(results => {
  results.forEach(result => console.log(result.status));
  // fulfilled
  // rejected
  // fulfilled
});
```
#### 补充
- 使用场景：
  - Promise.all：
    - 当你希望所有任务都成功才能执行下一步操作时。
    - 比如加载多个资源图片，如果任何一张图片加载失败，都不执行后续操作。
  - Promise.allSettled：
    - 当你希望并行执行多个任务并查看每个任务的结果时，即使某些任务可能失败。
    - 例如，批量获取多个用户数据，即使有部分用户数据获取失败，也不影响处理其他用户数据。
- 错误处理：
  - 在使用 Promise.all 时，必须处理可能的拒绝情况，通常使用 .catch() 方法来处理。
  - Promise.allSettled 则会返回每个 promise 的状态，不需要专门捕获拒绝错误，处理方式更加灵活和容错。
- 性能考虑：
  - 两者的性能在大多数情况下是相似的，因为它们都并行执行所有的 promise。
  - 不过，如果你希望在某个 promise 拒绝时就停止执行，Promise.all 可能会更高效，因为它会立即拒绝，终止剩余 promise 的处理。

### 说说你对 Promise 的理解 ?
#### 含义
- Promise 是 JavaScript 中用于处理异步操作的一种对象。
- 它代表了一个尚未完成但承诺会在未来某个时候完成的操作，并允许你在操作完成前注册回调函数。
#### 主要状态
- Pending（等待）：初始状态，操作未完成，也没有成功或失败。
- Fulfilled（已实现）：操作成功完成，并得到了一个值。
- Rejected（已拒绝）：操作失败，并返回一个原因。
#### 作用、好处
- 使用 Promise 可以写出更简洁、可读性更好的代码。
- 避免了使用传统回调函数（callback）的“回调地狱”问题。
#### 补充
```js
// 1、Promise 的基本用法
let promise = new Promise((resolve, reject) => {
  // 异步操作
  setTimeout(() => {
    let success = true; // 这里可以是任何异步操作结果
    if (success) {
        resolve('操作成功'); // 操作成功，传递结果
      } else {
        reject('操作失败'); // 操作失败，传递原因
      }
    }, 1000);
});
promise.then(result => {
  console.log(result); // 操作成功时处理
}).catch(error => {
  console.error(error); // 操作失败时处理
});

// 2、链式调用
// Promise 的一个强大之处在于它们可以链式调用，从而更好地管理异步流程。
new Promise((resolve, reject) => {
  setTimeout(() => resolve(1), 1000); // 初始 Promise
}).then(result => {
  console.log(result); // 输出 1
  return result * 2; // 返回一个新的值
}).then(result => {
  console.log(result); // 输出 2
  return result * 2;
}).then(result => {
  console.log(result); // 输出 4
}).catch(error => {
  console.error(error);
});

// 3、多个 Promise 的并发处理
// 有时需要并发处理多个异步操作，可以使用 Promise.all、Promise.race 等方法。
let promise1 = new Promise(resolve => setTimeout(() => resolve('Promise 1 完成'), 1000));
let promise2 = new Promise(resolve => setTimeout(() => resolve('Promise 2 完成'), 2000));

// 使用 Promise.all 等待所有 Promise 完成
Promise.all([promise1, promise2]).then(results => {
  console.log(results); // ["Promise 1 完成", "Promise 2 完成"]
}).catch(error => {
  console.error(error);
});
// 使用 Promise.race 只等待第一个完成的 Promise
Promise.race([promise1, promise2]).then(result => {
  console.log(result); // "Promise 1 完成"
}).catch(error => {
  console.error(error);
});

// 4、与 async/await 结合使用
// 自从 ES2017 引入 async/await 语法后，处理异步操作变得更加直观。
async function asyncFunction() {
  try {
      let result1 = await promise1; // 等待 promise1 完成
      console.log(result1);
      let result2 = await promise2; // 等待 promise2 完成
      console.log(result2);
    } catch (error) {
      console.error(error);
  }
}
asyncFunction();
```

### JavaScript 中异步编程的实现方式有哪些 ?
#### 为什么会诞生异步编程
- JavaScript 是单线程语言，单线程意味着同一时间只能做一件事情
- 那么如何处理 I/O 操作（如网络请求、定时任务）这样的耗时任务呢？
- 这就需要异步编程来帮忙
#### 主要的异步编程方式
- 回调函数
- Promise
- Async/Await
```js
// 1、回调函数（Callbacks）
// 最早、也是最基础的异步编程方式
// 将一个函数作为参数传递给另一个函数，让这个函数在后续某个时刻调用它
// 优点：简单明了，容易理解和实现。
// 缺点：容易产生“回调地狱”（Callback Hell），即回调函数嵌套过多，代码变得难以阅读和维护。
function doSomething(callback) {
  setTimeout(() => {
    console.log("Something done!");
    callback();
  }, 1000);
}
doSomething(() => {
  console.log("Callback executed!");
});

// 2、Promise
// Promise 是 ES6 引入的新特性，用于解决回调地狱问题。
// 它可以让异步操作以一种链式调用的方式进行。
// 优点：
//  可以链式调用 .then()，使代码可读性更高。
//  更好地处理错误，可以使用 .catch() 捕获异常。
// 缺点: 需要一些时间去理解和掌握，因为相比回调函数稍微复杂一些。
function doSomething() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log("Something done!");
      resolve("Success!");
    }, 1000);
  });
}
doSomething().then((message) => {
  console.log(message);
}).catch((error) => {
  console.error(error);
});

// 3、Async/Await
// Async/Await 是基于 Promise 之上的语法糖，使得异步代码看起来更像同步代码，提高了代码的可读性和可维护性。
// 这在 ES2017（ES8） 中被引入。
// 优点：
//  使异步代码风格更加直观，写起来类似于同步代码。
//  错误处理变得更加简单，可以使用 try-catch。
// 缺点：需要在函数前使用 async 关键字，增加了一点学习成本。
async function doSomething() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log("Something done!");
      resolve("Success!");
    }, 1000);
  });
}
async function asyncCall() {
  try {
    const message = await doSomething();
    console.log(message);
  } catch (error) {
    console.error(error);
  }
}
asyncCall();
```
#### 其他的异步编程方式
- 事件循环（Event Loop）：是 JavaScript 的执行模型，它使得非阻塞 I/O 操作成为可能。
- Generator：通过 yield 关键字，可以实现异步逻辑的暂停和恢复。
- 流行库：如 RxJS 提供更加强大的异步操作能力，被广泛应用于复杂的前端应用中（如 Angular）。

### setTimeout、Promise、Async/Await 有什么区别 ? 
setTimeout、Promise 和 Async/Await 都是 JavaScript中用来处理异步操作的方法，但它们有着不同的使用场景和特点。
- setTimeout：用于定时执行代码。
- Promise：表示一个异步操作的最终完成或失败及其结果值。
- Async/Await：是Promise的语法糖，提供了更简洁的异步代码写法。
```js
// 1、setTimeout
// setTimeout是一种较为原始的异步操作方法。
// 它的主要作用是延迟执行某段代码。
// 使用时需要指定一个延迟时间（以毫秒为单位）
console.log("Start");
setTimeout(() => {
    console.log("Hello after 1 second");
}, 1000);
console.log("End");
// “Start” 和 “End” 会立即打印，而 “Hello after 1 second” 会在1秒后打印。
// 延伸：setInterval是setTimeout的“兄弟”，用于定时反复执行某段代码。

// 2、Promise
// Promise 是 ES6 引入的一种处理异步操作的机制，Promise 更加易读和可管理。
// 它可以有三种状态：pending（进行中）、fulfilled（已成功）、rejected（已失败）。
// 一个 Promise 对象创建后可能处于这三种状态中的一种，并在它的生命周期内可以从 pending 变成 fulfilled 或 rejected。
let myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Success!");
  }, 1000);
});
myPromise.then(result => {
  console.log(result); // "Success!"
}).catch(error => {
  console.log(error);
});
// 延伸：Promise.all、Promise.race等方法允许对多个 Promise 进行处理。

// 3、Async/Await
// Async/Await 是 ES2017 引入的用于处理异步操作的更简洁的语法，它使得使用异步代码像写同步代码一样简单和直观。
// 本质上，async 声明一个函数是异步的，await 暂停异步函数的执行，等待Promise解决后再继续执行。
async function asyncFunc() {
  console.log("Start");
  let result = await myPromise; // 遇到 await 暂停，等 myPromise 执行完后后继续执行
  console.log(result); // "Success!"
  console.log("End");
}
asyncFunc();
// 延伸：使用 Async/Await 时需要注意异常处理，可以用 try...catch 语句来捕获异常。
```

### Promise 有哪些基本用法 ?
#### 创建 Promise
- 通过 new Promise((resolve, reject) => {...}) 可以创建一个新的 Promise。
- 其中 resolve 和 reject 是两个函数，分别在异步操作成功和失败时调用。
```js
let promise = new Promise((resolve, reject) => {
  // 做一些异步操作
  setTimeout(() => {
    let success = true;
    if (success) {
      resolve("操作成功！");
    } else {
      reject("操作失败！");
    }
  }, 1000);
});
```
#### 链式调用
- `.then(onFulfilled, onRejected)` : 当 Promise 成功时调用 `onFulfilled`，失败时调用 `onRejected`
- `.catch(onRejected)` : 处理 Promise 的拒绝情况，也就是快捷方式用于 `.then(null, onRejected)`
- `.finally(onFinally)` : 不论 Promise 的结果如何，最终都会执行 `onFinally` 指定的函数
```js
promise
  .then((result) => {
    console.log(result); // 打印：操作成功！
  })
  .catch((error) => {
    console.log(error);
  })
  .finally(() => {
    console.log("操作完成");
  });
```
#### 静态方法
- `Promise.resolve(value)` : 返回一个以给定值进行解决的 Promise 对象
- `Promise.reject(reason)` : 返回一个以给定理由进行拒绝的 Promise 对象
- `Promise.all(iterable)` : 接受一个 Promise 对象的数组（或类数组），当所有 Promise 都完成时返回一个新的 Promise，且返回值是按 Promise 的顺序组成的数组
- `Promise.race(iterable)` : 接受一个 Promise 对象的数组，一旦有一个 Promise 完成或拒绝，则返回该 Promise 的值或原因
```js
// 使用 Promise.resolve
let resolvedPromise = Promise.resolve("Resolved！");
resolvedPromise.then(console.log); // 打印：Resolved！

// 使用 Promise.reject
let rejectedPromise = Promise.reject("Rejected！");
rejectedPromise.catch(console.log); // 打印：Rejected！

// 使用 Promise.all
let p1 = Promise.resolve(1);
let p2 = Promise.resolve(2);
let p3 = Promise.resolve(3);
Promise.all([p1, p2, p3]).then(values => {
  console.log(values); // 打印：[1, 2, 3]
});

// 使用 Promise.race
let p4 = new Promise((resolve) => setTimeout(resolve, 2000, "Two seconds"));
let p5 = new Promise((resolve) => setTimeout(resolve, 1000, "One second"));
Promise.race([p4, p5]).then(value => {
  console.log(value); // 打印：One second
});
```

### Promise 解决了什么问题 ?
#### 解决地狱回调问题
- 在传统的 JavaScript 异步编程中，我们通常会使用回调函数来处理异步操作。
- 随着异步操作逐渐增多，回调函数会嵌套的越来越深，这种现象被称为回调地狱。
- 代码结构变得复杂且难以维护。
#### 解决异步编程管理
- Promise 为异步编程提供了一种更加优雅的解决方案。
- 使用链式调用来处理异步操作，从而提高了代码的可读性和可维护性。
#### 知识补充
##### 回调地狱（Callback Hell）
- 回调函数相互嵌套，导致代码难以阅读和维护
```js
fs.readFile('file1.txt', function(err, data1) {
  if (err) throw err;
  fs.readFile('file2.txt', function(err, data2) {
    if (err) throw err;
    fs.readFile('file3.txt', function(err, data3) {
      if (err) throw err;
      // 继续嵌套下去...
    });
  });
});
```
##### Promise 的基本用法 
- Promise 是一个构造函数，通过 `new Promise` 可以创建一个 Promise 实例
```js
let myPromise = new Promise(function(resolve, reject) {
  setTimeout(function() {
    resolve("成功！");
  }, 1000);
});

myPromise.then(function(value) {
  console.log(value); // 成功！
}).catch(function(error) {
  console.log(error);
});
```
##### 链式调用
- Promise 的链式调用可以让我们避免回调地狱。
- 每个 `.then` 方法都会返回一个新的 Promise，因此可以使用链式调用处理多个异步操作。
- 相比回调地狱，Promise 使得代码更加扁平和可读。
```js
fetch(url1)
  .then(response => response.json())
  .then(data => fetch(url2))
  .then(response => response.json())
  .then(data => fetch(url3))
  .then(response => response.json())
  .then(data => {
    console.log("All requests completed!");
  })
  .catch(error => {
    console.error("Error:", error);
  });
```
##### Promise.all 和 Promise.race
- `Promise.all` : 当传入的所有 Promise 都完成（或其中一个失败）时，它会返回一个新的 Promise，新的 Promise 的值是所有 Promise 返回值组成的数组。
```js
Promise.all([promise1, promise2, promise3]).then(values => {
  console.log(values); // [结果1, 结果2, 结果3]
}).catch(error => {
  console.error("Error:", error);
});
```
- `Promise.race` : 只要其中一个 Promise 解决或拒绝，它就会返回。
```js
Promise.race([promise1, promise2, promise3]).then(value => {
  console.log(value); // 最先解决或拒绝的结果
}).catch(error => {
  console.error("Error:", error);
});
```

### Promise.all 和 Promise.race 分别有哪些使用场景 ? 有什么区别 ?
它们的主要区别在于如何处理多个 Promise，并且在不同的使用场景下表现出各自的优势。
- `Promise.all` 使用场景
  - 等待所有异步操作完成 :
    - 当你有一组异步操作，并且你希望在所有这些操作都完成之后再进行下一步时，使用 Promise.all。
    - 它会同时执行所有 Promise，并且只有当所有 Promise 都 resolved 或者有一个 Promise rejected 时，Promise.all 才会结束。
  - 处理多个独立的异步请求结果 : 比如获取多个 API 的数据，然后组合结果来进行后续操作。
- `Promise.race` 使用场景
  - 竞争条件 :
    - 当你有多个异步操作，但是你只关心其中最先完成的一个结果时使用 Promise.race。
    - 无论是 resolved 还是 rejected，只要有一个 Promise 状态发生变化，Promise.race 就会结束。
  - 超时控制 : 比如你需要设置一个超时机制，如果某个操作耗时过长，就选择另一个备选方案或者处理操作超时的逻辑。
#### 代码示例
##### Promise.all 的示例
```js
const promise1 = fetch('https://api.example1.com/data');
const promise2 = fetch('https://api.example2.com/data');
const promise3 = fetch('https://api.example3.com/data');

Promise.all([promise1, promise2, promise3])
  .then((results) => {
    return Promise.all(results.map(r => r.json()));
  })
  .then((data) => {
    console.log(data); // data 是一个包含了三个 API 响应结果的数组
  })
  .catch((error) => {
    console.error('其中一个请求失败：', error);
  });
```
##### Promise.race 示例
```js
const p1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 500, 'p1 完成');
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'p2 完成');
});

Promise.race([p1, p2])
  .then((result) => {
    console.log(result); // 'p2 完成', 因为 p2 比 p1 完成得更快
  })
  .catch((error) => {
    console.error('有一个 promise 被拒绝：', error);
  });

// 超时控制的示例
const fetchWithTimeout = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error('请求超时')), 5000);
});

Promise.race([fetch('https://api.example.com/data'), fetchWithTimeout])
  .then((result) => {
    return result.json();
  })
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.error('错误：', error);
  });
```

### 说说你对 async/await 的理解 ?
#### 含义
- `async/await` 是用来处理 JavaScript 中异步操作的一种语法糖
  - `async` 用来声明一个函数为异步函数
  - `await` 用来等待一个 Promise 对象的结果
#### 作用
让异步代码看起来更像是同步代码，从而简化代码的可读性和可维护性
#### 使用
- `async` 关键字：将一个函数声明为异步函数，返回一个 Promise 对象。
- `await` 关键字：
  - 只能在 `async` 声明的函数内部使用，用来等待一个 Promise 对象的结果，然后返回该结果。
  - 如果等待的 Promise 被拒绝，则会抛出异常，可以使用 `try...catch` 来捕获异常。
#### 补充
##### 异步编程方式和其发展历程
最早的回调函数（callback）开始，经历了 Promise，再到现在的 async/await，每一步都是为了让异步编程更加高效和易读。
##### 回调函数
最原始的方法，通过回调函数实现异步操作，但是回调函数嵌套深了会导致“回调地狱”（callback hell），代码变得非常难以维护。
```js
function fetchData(callback) {
  setTimeout(() => {
    callback(null, 'data');
  }, 1000);
}

// 使用回调
fetchData((error, data) => {
  if (error) {
    console.error(error);
  } else {
    console.log(data);
  }
});
```
##### Promise
Promise 提供了链式调用的方式，解决了回调地狱的问题，使得代码更容易理解。
```js
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('data');
    }, 1000);
  });
}

// 使用 Promise
fetchData()
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```
##### async/await
async/await 是基于 Promise 的语法糖，让异步代码的写法更加接近同步代码的写法，使得代码更加简洁易读。
```js
async function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('data');
    }, 1000);
  });
}

// 使用 async/await
async function getData() {
  try {
    const data = await fetchData();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

getData();
```
> [!TIP]
> 通过对比可以发现，async/await 让异步代码更加简洁明了，不用写那么多 `.then` 和 `.catch`，更好地处理错误并且提高代码的可读性。
> 不过要注意，`await` 只能在 `async` 函数中使用。

### async/await 是否会阻塞代码的执行 ?
- async/await 本身不会阻塞代码的执行。
- 它是基于 Promise 的语法糖，用来更简洁地处理异步操作。
- await 会暂停 async 函数的执行，等待 Promise 结果，但不会阻塞主线程，其它的 JavaScript 代码依然会继续执行。
#### 补充
##### async 函数
- async 关键字用来声明一个函数，该函数默认返回一个 Promise。
- 任何被 async 声明的函数，其返回值会被自动封装成一个 Promise 对象。
```js
async function example() {
  return "Hello";
}
// 调用 example()，实际会返回一个 Promise，
// 该 Promise 的解析值为 "Hello"
example().then(result => console.log(result));
```
##### await 关键字
- await 关键字只能在 async 函数内部使用，用来等待一个 Promise 的解决。
- 在等待期间，async 函数中的代码暂停执行，但不会阻塞整个程序的运行。
- 当 Promise 解决时，暂停的代码会继续执行，并返回 Promise 的解决值。
```js
async function fetchData() {
  let response = await fetch('https://api.example.com/data');
  let data = await response.json();
  console.log(data);
}
fetchData();
```
##### 事件循环（Event Loop）
- 要理解 async/await 不会阻塞代码执行，需要了解 JavaScript 的事件循环机制。
- JavaScript 是单线程的，通过事件循环来处理异步操作。
- 当遇到 await 关键字，当前任务被挂起，事件循环会继续执行其他任务，直到 Promise 解决或拒绝。
##### 错误处理
async/await 处理错误比传统的 Promise 链要简洁，可以使用 try/catch 语句。
```js
async function fetchData() {
  try {
    let response = await fetch('https://api.example.com/data');
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}
fetchData();
```
##### 并行执行
当有多个异步操作时，可以使用 `Promise.all` 同时处理。
```js
async function parallelFetch() {
  let [response1, response2] = await Promise.all([
    fetch('https://api.example.com/data1'),
    fetch('https://api.example.com/data2')
  ]);
  let data1 = await response1.json();
  let data2 = await response2.json();
  console.log(data1, data2);
}
parallelFetch();
```

### await 到底在等待什么 ?
- 在 JavaScript 中，`await` 是一个用于等待 `async` 函数返回的 Promise 被解决或拒绝的关键词。
  - 等待解决 (resolved) 意味着等待 Promise 变得成功 (fulfilled)。
  - 等待拒绝 (rejected) 意味着 Promise 变得失败 (rejected)。

- `await` 等待的是异步操作完成，然后获取其结果。
  - 如果该异步操作返回一个 Promise，`await` 会暂停执行。
  - 直到这个 Promise 解决或拒绝为止。

#### 补充
##### 基础用法
假设你有一个异步函数 fetchData，它返回一个 Promise，你可以使用 `await` 来等待这个异步操作完成
```js
async function getData() {
  try {
    const data = await fetchData();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}
```
##### 作用
`await` 能简化异步代码结构，使其看起来更接近同步代码，降低复杂度，避免嵌套回调地狱。
##### Error Handling (错误处理)
使用 `try...catch` 语法块可以优雅地捕获并处理异步操作中的异常。如上例中的错误捕获机制。
##### 顶层 `await`
从 ECMAScript 2020 开始，支持在模块顶层使用 `await`。这允许开发者在模块级别编写结构良好的异步代码。
```js
const response = await fetch('https://api.example.com/data');
const data = await response.json();
console.log(data);
```
##### 队列机制
当使用 `await` 时，JavaScript 事件循环机制会创建一个微任务来处理Promise的解决结果，这也就是为什么 await 会暂停函数执行，而不会阻塞整个线程。
##### 与 `Promise.all` 结合
`await` 可以与 `Promise.all` 结合使用，来并行等待多个异步操作。
```js
async function getAllData() {
  const [response1, response2] = await Promise.all([fetchData1(), fetchData2()]);
  console.log(response1, response2);
}
```
##### 性能注意事项
虽然 `await` 使用起来很方便，但在不必要的地方滥用可能会降低性能。尽量在实际需要的场景中使用等待，避免不必要的阻塞。

### async/await 对比 Promise 的优势是什么 ?
#### 优势
- <mark>代码可读性更高</mark>
  - `async/await` 让异步代码看起来像同步代码，大大提高了代码的可读性和维护性。
- <mark>错误处理更加简单直观</mark>
  - 在 `async/await` 中你可以使用 `try/catch` 来捕获错误，这使得错误处理更加直观和一致。
- <mark>错误处理更加简单直观</mark>
  - 当使用链式 Promise 时，很容易陷入 “回调地狱”（回调嵌套过深），而 `async/await` 可以很好地避免这一点。
#### 补充
##### 可读性与简洁性
- 当我们使用 Promise 时，通常会看到类似 `.then()` 或 `.catch()` 的链式调用。
- 这虽然允许我们处理多个异步操作，但一旦链条变长，可读性就会大大降低。
- 而 `async/await` 则通过语法糖使代码更加接近于同步的写法。
::: code-group
```js [promise.js]
// 使用 Promise 的典型写法
getData()
  .then(response => {
    return processData(response);
  })
  .then(result => {
    return saveData(result);
  })
  .catch(error => {
    console.error("Error:", error);
  });

```
```js [async-await.js]
// 使用 async/await 的写法
async function fetchAndProcessData() {
  try {
    const response = await getData(); // [!code highlight]
    const result = await processData(response); // [!code highlight]
    await saveData(result); // [!code highlight]
    // 使用 async/await 后，整个代码块显得更加简洁且逻辑清晰。
  } catch (error) {
    console.error("Error:", error);
  }
}
```
:::
##### 错误处理
- 使用 `async/await` 后，我们可以很容易地通过 `try/catch` 块来进行错误捕获。
- 而不用在每个 `.then()` 和 `.catch()` 块中进行单独处理。
- 这使得错误处理逻辑更加集中，易于管理。
::: code-group
```js [promise.js]
// 使用 Promise 的错误处理
getData()
  .then(response => {
    // some processing
  })
  .catch(error => {
    // handle error
  });
```
```js [async-await.js]
// 使用 async/await 的错误处理
async function fetchData() {
  try {
    const response = await getData();
    // some processing
  } catch (error) {
    // handle error
  }
}
```
:::
##### 避免回调地狱
使用 Promise 虽然解决了一定程度的嵌套问题，但在复杂的多层异步操作下，依然容易出现回调地狱。而 `async/await` 则通过线性的代码流程完全规避了这个问题，使代码更加平滑。
##### 调试友好
在调试过程中，使用 `async/await` 可以像调试同步代码一样使用断点调试工具。而使用 Promise 时，调试工具往往需要依靠 `.then()` 链中的上下文，使得调试复杂性增加。

### async/await 如何捕获异常 ?
- 在 JavaScript 中，使用 `async/await` 处理异步操作时，捕获异常的方式主要是通过 `try/catch` 语句。
- 简而言之，你可以把 await 操作包裹在 `try/catch` 块中，这样当异步操作出现异常时，`catch` 块就会捕获到这个异常。
```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching data:', error);
    // Handle the error appropriately, e.g., return a default value or rethrow the error
    throw error; // 如果需要上层继续处理异常，可以重新抛出
  }
}

fetchData().then(data => {
  console.log(data);
}).catch(error => {
  console.error('Error in fetchData execution:', error);
});
```
#### 补充
##### 错误传播
- 当在 `async` 函数中使用 `await` 时，如果 `await` 的表达式抛出异常，这个异常会被包裹在返回的 Promise 里。
- 如果你不在 `async` 函数里捕获这个异常，那么调用这个 `async` 函数的地方可以通过 `.catch()` 方法来捕获异常。
- 也就是说，`try/catch` 并不是唯一的捕获方式。
```js
async function failingFunction() {
  await Promise.reject(new Error('Something went wrong'));
}

failingFunction().catch(error => {
  console.error('Caught an error:', error.message);
});
```
##### Promise.all 的异常处理
- 当使用 `Promise.all()` 处理并发异步操作时，只要其中一个 Promise 被拒绝，Promise.all 返回的 Promise 就会立即被拒绝。
- 此时可以使用 `try/catch` 块来捕获异常，或者在 Promise.all 后面直接使用 `.catch()` 方法。
```js
async function multipleFetch() {
  try {
    const [data1, data2] = await Promise.all([
      fetch('https://api.example.com/data1').then(res => res.json()),
      fetch('https://api.example.com/data2').then(res => res.json())
    ]);
    return { data1, data2 };
  } catch (error) {
    console.error('Error in one of the promises:', error);
    throw error;
  }
}

multipleFetch().then(result => {
  console.log('Fetched data:', result);
}).catch(error => {
  console.error('Error in multipleFetch execution:', error);
});
```
#### 最终捕获 (finally)
- 除了 `try/catch`，还有一种常见的模式是 `finally`。
- 在处理完异常后常常需要执行一些清理工作，比如关闭连接、释放资源等。这时，finally 就很有用了。
```js
async function fetchDataWithCleanup() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching data:', error);
    throw error;
  } finally {
    console.log('Cleanup after fetch attempt');
    // 这里可以放一些清理资源的代码，比如关闭数据库连接等
  }
}
```

### 什么是回调函数 ? 回调函数有什么缺点 ?
#### 含义
- 回调函数（Callback）是在JavaScript中非常常见的概念，指的是将一个函数作为参数传递给另一个函数，并在适当的时候执行该参数函数。
#### 动机
- 这样做的目的是为了在一个操作完成后执行某个指定的操作。
#### 使用场景
- 回调函数在处理异步操作（如网络请求、定时器和事件监听）时尤为常用。
#### 缺点
- 回调函数的一个主要缺点是“回调地狱”（Callback Hell），也称作“金字塔地狱”（Pyramid of Doom），当多个异步操作需要依次执行，出现嵌套的回调函数，使代码变得难以阅读和维护。
#### 补充
##### 回调函数的优点
- 回调函数非常灵活，能让函数之间解耦，避免了代码的同步阻塞，尤其在非阻塞I/O操作中，这是一个很大的优势。
##### 回调函数的缺点
- 回调地狱 : 当有多个异步任务需要按照顺序执行时，会导致代码层层嵌套，进而使代码难以维护和调试。
```js
asyncOperation1(function(result1) {
  asyncOperation2(result1, function(result2) {
    asyncOperation3(result2, function(result3) {
      // 继续下去
    });
  });
});
```
- 错误处理复杂 : 在回调函数中处理错误情况可能会非常混乱。每个回调都需要检查错误并适当处理，这使代码更难以管理。
##### 解决方案
- Promise : Promise 提供了一种更清晰、链式的方式来处理异步操作，避免了回调地狱。
```js
asyncOperation1()
  .then(result1 => asyncOperation2(result1))
  .then(result2 => asyncOperation3(result2))
  .catch(error => {
    // 统一处理错误
  });
```
- Async/Await: Async/Await是基于Promise的语法糖，使异步代码看起来和写起来更像同步代码，进一步提高了代码的可读性。
```js
async function runAsyncTasks() {
  try {
    const result1 = await asyncOperation1();
    const result2 = await asyncOperation2(result1);
    const result3 = await asyncOperation3(result2);
  } catch (error) {
    // 统一处理错误
  }
}
runAsyncTasks();
```
##### 回调函数的应用场景
- Event Handling: 在事件驱动的编程环境中，如点击按钮后的操作。
- 定时器: 在使用setTimeout或setInterval时传递的回调函数。
- 网络请求: 在发起AJAX请求后处理响应数据的回调函数。

### JavaScript 中如何解决回调地狱问题 ?
- 在 JavaScript 中，要解决回调地狱（Callback Hell）问题，最常用的方式有三种：
  - 1、使用 Promise。
  - 2、使用 async/await。
  - 3、模块化回调函数。
- 它们都是为了解决嵌套过深的回调函数导致的代码难以阅读和维护的问题。
#### 代码示例
::: code-group
```js [Promise.js]
// Promise 提供了一种链式调用的方法，可以让代码看起来更加清晰。
// 通过 then() 方法，你可以在回调完成后立即处理返回值，而不用不断地嵌套回调函数。
function doSomething() {
  return new Promise((resolve, reject) => {
    // 一些异步操作
    if (/* 成功条件 */) {
    resolve('成功');
  } else {
    reject('失败');
  }
  });
}
doSomething()
  .then(result => {
    console.log(result);
    return doSomethingElse();
  })
  .then(anotherResult => {
    console.log(anotherResult);
  })
  .catch(error => {
    console.error(error);
  });
```
```js [async-await.js]
// async/await 是基于 Promise 的语法糖，通过这种方式可以让异步代码看起来更加同步，进一步提升了代码的可读性。
// 它简化了异常处理，使得错误处理更加直观。
async function asyncFunc() {
  try {
    const result = await doSomething();
    console.log(result);
    const anotherResult = await doSomethingElse();
    console.log(anotherResult);
  } catch (error) {
    console.error(error);
  }
}
asyncFunc();
```
```js [module-callback.js]
// 通过将回调函数模块化，把每一个回调函数作为一个独立的模块，这样可以减少嵌套的层次，使代码更易于维护。
function firstTask(callback) {
  // 一些异步操作
  callback(null, '结果一');
}
function secondTask(input, callback) {
  // 一些异步操作
  callback(null, '结果二');
}
firstTask((err, result) => {
  if (err) {
    console.error(err);
    return;
  }
  secondTask(result, (err, anotherResult) => {
    if (err) {
      console.error(err);
      return;
    }
    console.log(anotherResult);
  });
});
```
:::
#### 补充
除了上述最常用的三种方法，还有其他方式可以进一步提升代码质量和可读性
- 事件驱动编程: 
  - 通过引入事件驱动的模型，比如使用 Node.js 的 EventEmitter 类，可以在达到某个条件时触发特定的事件，从而避免嵌套的回调函数。
- RxJS:
  - 这是一个用于处理复杂异步逻辑的库，通过 Observable 的方式提供了一种更强大的处理异步操作的方法。
  - 它允许你使用流式方法操作异步数据流。
- 生成器函数：
  - 生成器函数（Generator Functions）结合 co 这样的库，可以将异步执行流控制得更好，但它通常不如 async/await 简洁直接。
  ::: details 代码示例
  ```js
  const co = require('co');
  function generatorFunc() {
    try {
      const result = yield doSomething();
      console.log(result);
      const anotherResult = yield doSomethingElse();
      console.log(anotherResult);
    } catch (err) {
      console.error(err);
    }
  }
  co(generatorFunc);
  ```
  :::

### setTimeout、setInterval、requestAnimationFrame 各有什么特点 ?
- `setTimeout` 
  - 在指定的时间后执行一次代码。时间延迟是由你设置的毫秒数决定的。
  - 很适合在一段时间后执行某个操作，例如模态框的自动关闭，轻松实现一次性的延时任务。
  - > [!WARNING] 时间可能不会精确到设定的毫秒数，因为 JavaScript 是单线程的，其他任务也可能会影响到它的执行时间。
- `setInterval` 
  - 每隔指定的时间间隔重复执行代码，直到被明确中止。
  - 时间可能不会精确到设定的毫秒数，因为 JavaScript 是单线程的，其他任务也可能会影响到它的执行时间。
  - > [!WARNING] 注意内存泄漏和定时器的清除，最好在使用完之后调用 clearInterval()。
- `requestAnimationFrame` 
  - 专门用于高性能动画，因为它会在浏览器下一次重绘之前执行回调，使动画更加平滑和高效。
  - 页面隐藏或最小化时会暂停执行，这对于省电和性能优化都很有好处。
#### 代码示例
::: code-group
```js [setTimeout.js]
setTimeout(() => {
  console.log("This runs once after 1 second.");
}, 1000);
```
```js [setInterval.js]
const intervalId = setInterval(() => {
  console.log("This runs every 2 seconds.");
}, 2000);

// Clear the interval after 10 seconds
setTimeout(() => {
  clearInterval(intervalId); // [!code highlight]
  console.log("Interval cleared.");
}, 10000);
```
```js [requestAnimationFrame.js]
function animate() {
  // 动画代码
  console.log("Animating...");
  // 下一帧继续动画
  requestAnimationFrame(animate);
}

// 开始动画
requestAnimationFrame(animate);
```
:::

### JavaScript 中 WeakMap 和 Map 的区别
> [!TIP] 都是 JavaScript 中用来存储键值对的数据结构

- 键类型
  - `Map` 的键可以是任意类型的值（包括对象、原始类型）。
  - `WeakMap` 的键只能是对象。
- 垃圾回收
  - `Map` 对键值对都有强引用，因此不会因为键不再被引用而自动释放空间。
  - `WeakMap` 的键是弱引用，如果没有其他对键的引用，该键所对应的键值对将会被垃圾回收机制回收，从而释放内存。
- 迭代性
  - `Map` 是可迭代的，可以使用 forEach 方法和 for...of 循环等来遍历键值对。
  - `WeakMap` 不可迭代，没有 forEach 方法或者其他类似的方法。
- 应用场景
  - `Map` 一般用在需要存储任意键值对的情况，且不关心垃圾回收问题的场景。
  - `WeakMap` 主要用于存储临时对象的数据，特别是在需要避免内存泄漏的场景下。

#### 补充
##### 内存管理
- `WeakMap` 提供了一种可以避免内存泄漏的方法。
- 在一般的编程中，如果我们不小心创建了大量的对象，并将这些对象作为键存储在 `Map` 中。
- 这些对象即使在其他地方不再被引用，仍然会被 `Map` 引用，导致内存无法被释放。
- 而使用 `WeakMap`，就可以防止这种情况的发生，因为 `WeakMap` 不会保持对键的强引用。
- 当键对象没有其他引用时，垃圾回收机制会自动回收该对象和相应的值。
##### 键的类型限制
- `WeakMap` 的这个键必须是对象的限制，虽然会带来一些不便，但它实际上也有设计上的合理性。
- 因为只有对象才可以作为弱引用的目标，原始值（如数字、字符串等）都是不可变且不会被垃圾回收机制回收的，所以它们不适用于 `WeakMap`。
##### 加密和私有数据
- `WeakMap` 常常被用于实现对象的私有数据。
- 在传统的 JavaScript 对象中，所有属性都是公开的，通过 `WeakMap`，我们可以在对象外部保存与之相关的私有数据。
- 例如，可以用 `WeakMap` 来实现类的私有属性，避免直接在类实例上暴露这些属性。
```js
const privateData = new WeakMap();

class MyClass {
  constructor(name) {
    privateData.set(this, { name });
  }

  getName() {
    return privateData.get(this).name;
  }
}

const obj = new MyClass('John');
console.log(obj.getName()); // John
console.log(obj.name); // undefined
```
##### 性能方面
- `Map` 通常用于需要频繁添加、删除、查找元素的情况，因为它在这些操作上有良好的性能表现。
- `WeakMap` 尽管不能被迭代，但由于其键是弱引用，这使得它在涉及大量临时对象的情况下性能更佳，有助于垃圾回收机制更有效地管理内存。

### JavaScript 中对象创建的方式有哪些 ?
::: code-group
```js [对象字面量.js]
// 这是最简单和最常见的创建对象的方式。
// 我们使用大括号 {} 来定义对象的属性和值。
const person = {
  name: 'John',
  age: 30
};
```
```js [Object构造函数.js]
// 使用 Object 构造函数可以创建一个空对象，然后可以添加属性。
const person = new Object();
person.name = 'John';
person.age = 30;
```
```js [构造函数.js]
// 这种方式使用一个构造函数去创建对象，可以让我们创建多个类似的对象。
// 构造函数是一个普通的函数，使用 new 操作符来调用。
function Person(name, age) {
  this.name = name;
  this.age = age;
}
const person1 = new Person('John', 30);
const person2 = new Person('Jane', 25);
```
```js [Object.create()方法.js]
// Object.create() 方法可以创建一个新对象。
// 它使用现有的对象来作为新对象的原型。
const prototype = {
  sayHi: function() {
    console.log('Hi!');
  }
};
const person = Object.create(prototype);
person.name = 'John';
person.age = 30;
```
```js [ES6类.js]
// ES6 引入了类的概念，这使得对象创建和继承更清晰和简洁。
// 类只是一个语法糖，它在幕后仍然使用的是构造函数和原型链。
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHi() {
    console.log('Hi!');
  }
}

const person1 = new Person('John', 30);
const person2 = new Person('Jane', 25);
```
:::

### JavaScript 中对象继承的方式有哪些 ?
#### 原型链继承（Prototype Chain Inheritance）
- 实现：通过将子类的原型指向父类的实例来实现。
- 优点：父类的方法可以被子类实例共享。
- 缺点：
  - 所有子类实例共享同一个原型对象，某个实例中的引用类型数据更改会影响其他实例。 
  - 在创建子类实例时不能向父类传参。
::: details 代码示例
```js
function Parent() {
  this.name = 'Parent';
  this.arr = [1, 2, 3];
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child() {}
Child.prototype = new Parent();

var child1 = new Child();
var child2 = new Child();
child1.arr.push(4);

console.log(child1.arr); // [1, 2, 3, 4]
console.log(child2.arr); // [1, 2, 3, 4]
```
:::
#### 借用构造函数继承（Constructor Stealing, also called Object Borrowing）
- 实现：在子类构造函数中调用父类构造函数。
- 优点：解决了原型链继承中引用类型共享的问题，可以传递参数。
- 缺点：无法继承父类原型上的方法，每个实例都有一份独立的父类的副本。
::: details 代码示例
```js
function Parent(name) {
  this.name = name;
  this.arr = [1, 2, 3];
}

function Child(name) {
  Parent.call(this, name);
}

var child1 = new Child('Child1');
var child2 = new Child('Child2');
child1.arr.push(4);

console.log(child1.arr); // [1, 2, 3, 4]
console.log(child2.arr); // [1, 2, 3]
```
:::
#### 组合继承（Combination Inheritance）
- 实现：结合原型链继承和借用构造函数继承。
- 优点：避免了引用对象共享问题，并且能够使用父类的原型方法。
- 缺点：父类构造函数会被调用两次。
::: details 代码示例
```js
function Parent(name) {
  this.name = name;
  this.arr = [1, 2, 3];
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

var child1 = new Child('Child1', 20);
var child2 = new Child('Child2', 30);
child1.arr.push(4);

console.log(child1.arr); // [1, 2, 3, 4]
console.log(child2.arr); // [1, 2, 3]
```
:::
#### 原型式继承（Prototypal Inheritance）
- 实现：通过一个函数将对象进行浅复制。
- 优点：比原型链继承更简单，不需要创建一个构造函数。
- 缺点：同样存在引用类型共享的问题。
::: details 代码示例
```js
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

var parent = {
  name: 'Parent',
  arr: [1, 2, 3]
};

var child = object(parent);
child.arr.push(4);

console.log(parent.arr); // [1, 2, 3, 4]
```
:::
#### 寄生式继承（Parasitic Inheritance）
- 实现：在原型式继承的基础上，增强对象，返回构造函数。
- 优点：可以在返回的对象中添加新的属性和方法。
- 缺点：跟组合继承一样，每次创建对象都会创建再从原型中得到的属性方法副本。
::: details 代码示例
```js
function createAnother(original) {
  var clone = object(original);
  clone.sayHi = function() {
    console.log('Hi');
  };
  return clone;
}

var parent = {
  name: 'Parent',
  arr: [1, 2, 3]
};

var child = createAnother(parent);
child.sayHi(); // Hi
```
:::
#### 寄生组合继承（Parasitic Combination Inheritance）
- 实现：结合寄生式继承和组合继承，解决组合继承中父类构造函数调用两次的问题。
- 优点：最优化的继承模式。
- 缺点：实现较复杂。
::: details 代码示例
```js
function Parent(name) {
  this.name = name;
  this.arr = [1, 2, 3];
}

Parent.prototype.getName = function() {
  return this.name;
};

function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}

Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

var child1 = new Child('Child1', 20);
var child2 = new Child('Child2', 30);
child1.arr.push(4);

console.log(child1.arr); // [1, 2, 3, 4]
console.log(child2.arr); // [1, 2, 3]
```
:::
#### ES6中的类继承（Class Inheritance）
- 实现：使用 class 关键字和 extends 关键字来实现类的继承。
- 优点：语法简单，语义清晰。
- 缺点：本质上还是基于原型链的继承。
::: details 代码示例
```js
class Parent {
  constructor(name) {
    this.name = name;
    this.arr = [1, 2, 3];
  }

  getName() {
    return this.name;
  }
}

class Child extends Parent {
  constructor(name, age) {
    super(name);
    this.age = age;
  }
}

let child1 = new Child('Child1', 20);
let child2 = new Child('Child2', 30);
child1.arr.push(4);

console.log(child1.arr); // [1, 2, 3, 4]
console.log(child2.arr); // [1, 2, 3]
```
:::

### JavaScript 中的 Proxy 与 Reflect 分别是什么 ? 两者有什么关系 ?
JavaScript 中的 Proxy 和 Reflect 是 ES6 引入的两个重要特性。<br>

`Proxy` 可以用于创建一个对象的代理，允许你拦截和自定义基本操作（例如属性访问、赋值、枚举、函数调用等）。<br>
`Reflect` 是一个内建对象，它提供了一些与 Proxy 对应的方法，用于对对象进行操作，可让对象内的操作更容易，并且更加语义化。<br>

两者关系密切，通常配合使用。<br>
`Proxy` 可以自定义操作行为，而 `Reflect` 提供默认行为及更标准化的操作方式。<br>
如果在 `Proxy` 对象中想要调用默认行为，可以直接用 `Reflect` 来实现。

#### 补充
#####  Proxy 的基本使用
```js
let target = {
  message1: "hello",
  message2: "everyone"
};

let handler = {
  get: function(target, prop, receiver) {
    eturn prop in target ? target[prop] : `Property ${prop} does not exist.`;
  }
};

let proxy = new Proxy(target, handler);
console.log(proxy.message1); // hello
console.log(proxy.nonexistent); // Property nonexistent does not exist.
```
##### Reflect 的基本使用
```js
let obj = { x: 1, y: 2 };

console.log(Reflect.has(obj, 'x')); // true
console.log(Reflect.get(obj, 'y')); // 2
Reflect.set(obj, 'z', 3);
console.log(obj.z); // 3
```
##### Proxy 和 Reflect 的配合使用
```js
let target = { name: 'Alice' };

let handler = {
  get: function(target, prop, receiver) {
    console.log(`Getting ${prop}`);
    return Reflect.get(target, prop, receiver); // 调用 Reflect 来获取默认行为
  },
  set: function(target, prop, value, receiver) {
    console.log(`Setting ${prop} to ${value}`);
    return Reflect.set(target, prop, value, receiver); // 调用 Reflect 来设定默认行为
  }
};

let proxy = new Proxy(target, handler);

proxy.name = 'Bob'; // Setting name to Bob
console.log(proxy.name); // Getting name, Bob
```
##### 更多的拦截操作
Proxy 可以拦截很多种操作，比如：`get`, `set`, `has`, `deleteProperty`, `apply`, `construct`, `defineProperty`, `getOwnPropertyDescriptor`, `isExtensible`, `ownKeys`, `preventExtensions`, `setPrototypeOf`, `getPrototypeOf` 等等。<br>
这让开发者可以非常细粒度地控制对象的行为。
##### 实际应用场景
- 数据验证和格式化：可以在设置属性值之前验证数据格式。
- 观察和调试：可以在属性访问或设置时做日志记录。
- 透明的远程调用：可以将一些操作代理到远程服务上，例如 RPC 调用。
- 虚拟化对象：通过代理提供类似对象的接口，但可能在后台做不同的事情，比如动态计算属性值。

### JavaScript 中如何实现寄生组合继承 ?
#### 1、创建一个函数，用于原型链继承父类的方法（SuperType）
```js
function inheritPrototype(subType, superType) {
  var prototype = Object.create(superType.prototype); // 创建对象
  prototype.constructor = subType; // 增强对象
  subType.prototype = prototype; // 赋值对象
}
```
#### 2、定义父类（SuperType）和子类（SubType）
```js
function SuperType(name) {
  this.name = name;
  this.colors = ["red", "blue", "green"];
}

SuperType.prototype.sayName = function() {
  console.log(this.name);
};

function SubType(name, age) {
  SuperType.call(this, name);  // 继承属性
  this.age = age;
}

inheritPrototype(SubType, SuperType);  // 继承方法

SubType.prototype.sayAge = function() {
  console.log(this.age);
};
```
通过这两个步骤，我们就实现了寄生组合继承，这种方式可以避免调用两次父类构造函数，从而提高性能。

### 为什么寄生组合继承是最佳的继承方式 ?
- 避免冗余调用<br>
在常见的组合继承中，父类的构造函数会被调用两次。一次是在创建子类原型时，另一次是在子类构造函数内部。如果父类的构造函数包含初始化逻辑，那么这些逻辑会被重复执行。寄生组合继承可以避免这个问题。
- 只需调用一次父类构造函数<br>
在寄生组合继承中，通过 SuperType.call(this, name) 在子类构造函数中调用父类构造函数，这样只调用一次父类构造函数，解决了组合继承的缺陷。
- 保持原型链的引用<br>
通过 Object.create(superType.prototype) 创建一个新对象，并将其作为子类原型，这样通过原型链可以正确访问父类的方法，而不会影响到各个实例之间的共享。
#### 代码示例
```js
// 父类
function Animal(name) {
  this.name = name;
  this.habitat = ["forest", "desert"];
}

Animal.prototype.makeSound = function() {
  console.log(this.name + " makes a sound.");
};

// 子类
function Bird(name, color) {
  Animal.call(this, name);  // 调用父类构造函数
  this.color = color;
}

inheritPrototype(Bird, Animal);  // 继承原型

Bird.prototype.fly = function() {
  console.log(this.name + " is flying with " + this.color + " feathers.");
};

// 使用
var parrot = new Bird("Parrot", "green");
parrot.makeSound();  // 输出：Parrot makes a sound.
parrot.fly();        // 输出：Parrot is flying with green feathers.
```

### 说说 JavaScript 中 instanceof 的原理 ?
JavaScript 中的 `instanceof` 用来检测一个对象是否在其原型链中存在某个构造函数的 `prototype` 属性。<br>
其原理是沿着对象的原型链逐级向上查找，看是否能找到该构造函数的 `prototype` 属性。<br>
简单来说，`instanceof` 可以回答 “对象是否是特定构造函数的实例” 这个问题。<br>
#### 补充
##### 具体操作步骤
1、首先获得对象的原型，通常是通过 `__proto__` 属性。<br>
2、然后，比较对象的原型是否与构造函数的 `prototype` 属性相等。
3、如果不相等，则继续沿着原型链向上查找，即获取对象原型的原型，重复步骤 2。
4、如果某环节原型与构造函数的 `prototype` 属性相等，则返回 `true`；如果查到顶链（即 `null`）仍不相等，则返回 `false`。
::: details 代码示例
```js
function Person() {}
var person = new Person();
console.log(person instanceof Person); // true
console.log(person instanceof Object); // true
console.log(person instanceof Array); // false
```
:::
##### 与 `typeof` 的区别
- `typeof` 用来检测一个变量或表达式的类型，它会返回一个字符串，指明操作数的类型，如 `undefined、string、boolean、number、object` 和 `function`。
- `instanceof` 则是专门用来检测对象与构造函数之间的关系，用于判断实例对象是否为某一数据类型。
##### Symbol.hasInstance
在 ES6 中，构造函数可以自定义 `instanceof` 行为。这是通过重写对象的 `Symbol.hasInstance` 方法来实现的。
```js
class MyClass {
  static [Symbol.hasInstance](instance) {
    return instance.customProperty === 'custom';
  }
}
const obj = { customProperty: 'custom' };
console.log(obj instanceof MyClass); // true
```
##### `instanceof` 与多层原型
`instanceof` 能够检测多层继承关系。<br>
例如，一个继承链条可能是 Employee -> Person -> Object，<br>
对于一个 Employee 的实例，`instanceof` 能正确返回它是 `Person` 和 `Object` 的实例<br>
```js
function Person() {}
function Employee() {}
Employee.prototype = new Person();
var employee = new Employee();

console.log(employee instanceof Employee); // true
console.log(employee instanceof Person);   // true
console.log(employee instanceof Object);   // true
```

### 说说 JavaScript 中 new 的原理 ?
在 JavaScript 中，`new` 操作符的主要作用是创建一个新对象，这个新对象是某个构造函数的实例。<br>
`new` 操作符的具体执行原理：<br>
1、创建一个新的空对象。<br>
2、将这个新对象的 `__proto__` 属性指向构造函数的 prototype 对象。<br>
3、将构造函数中的 this 绑定到新创建的对象上，并执行构造函数中的代码。<br>
4、如果构造函数返回了一个对象，那么 `new` 表达式最终会返回这个对象；否则，返回新创建的对象。<br>
::: details 代码示例
```js
function Person(name) {
  this.name = name;
}

const person = new Person("Alice");
console.log(person.name); // 输出 "Alice"
```
:::
#### 补充
##### 手写简化版的 new 函数
```js
function myNew(constructor, ...args) {
  // 1）创建一个新的空对象
  let obj = {};

  // 2）将这个新对象的 __proto__ 指向构造函数的 prototype 对象
  obj.__proto__ = constructor.prototype;

  // 3）将构造函数的 this 绑定到新对象上，并执行构造函数
  let result = constructor.apply(obj, args);

  // 4）如果构造函数返回了一个对象，那么返回这个对象；否则，返回新创建的对象
  return typeof result === 'object' && result !== null ? result : obj;
}

// 测试自定义的 myNew 函数
function Person(name) {
  this.name = name;
}

const person = myNew(Person, "Bob");
console.log(person.name); // 输出 "Bob"
```

##### 相关概念
- 构造函数：用于初始化对象的函数。<br>
构造函数通常与普通函数不同，因为它们通常首字母大写，并且需要与 new 操作符一起使用。
- 原型链：
对象与其原型之间的链条关系，当在一个对象上访问某个属性时，如果该对象上没有这个属性，JavaScript 会自动到它的原型上寻找。<br>
若原型上还没有，则逐级往上直到 Object.prototype。
- `apply` 和 `call` 方法：这两个方法分别用于在特定的 this 上调用函数。<br>
apply 与 call 的区别在于传递参数的方式，apply 接受一个包含参数的数组，而 call 接受参数列表。

### JavaScript 如何实现对象的深浅拷贝 ?
- 对于浅拷贝，可以使用`Object.assign`或者扩展运算符`...`。
- 对于深拷贝，可以使用`JSON.parse(JSON.stringify(obj))`或者利用递归来创建一个深度复制函数。

<mark>浅拷贝</mark><br>
1、`Object.assign(target, source)`：拷贝`source`对象的所有可枚举自身属性到`target`对象中。<br>
2、扩展运算符`...`：可以在对象字面量中使用，拷贝一个对象的所有可枚举属性。<br>

<mark>深拷贝</mark><br>
1、`JSON.parse(JSON.stringify(obj))`：这是最简单且常见的方式，但不支持函数和`undefined`等特殊值。<br>
2、递归：创建一个自定义函数，通过递归来复制对象的每一个属性，包括嵌套的对象或数组。<br>

> [!WARNING] 注意事项
> - 浅拷贝限制：如果对象包含嵌套的对象或数组，浅拷贝仅复制最外层对象的属性，而不会递归复制嵌套对象。
> - 深拷贝效率：深拷贝通常比浅拷贝慢，因为它涉及递归处理每个子对象，对于大型对象效率较低。
> - 特殊数据类型：`JSON.parse(JSON.stringify(obj))`并不处理`函数、undefined、Date对象`等。递归方式可以通过额外的判断处理这些特殊类型。
#### 代码示例
::: details 浅拷贝
::: code-group
```js [Object-assign.js]
const original = { a: 1, b: 2 };
const copy = Object.assign({}, original);
```
```js [扩展运算符.js]
const original = { a: 1, b: 2 };
const copy = { ...original };
```
:::

::: details 深拷贝
::: code-group
```js [JSON-parse-stringify.js]
const original = { a: 1, b: { c: 2 } };
const deepCopy = JSON.parse(JSON.stringify(original));
```
```js [递归.js]
function deepClone(obj) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (Array.isArray(obj)) {
    const copy = [];
    for (let i = 0; i < obj.length; i++) {
      copy.push(deepClone(obj[i]));
    }
    return copy;
  }

  const copy = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      copy[key] = deepClone(obj[key]);
    }
  }
  return copy;
}

const original = { a: 1, b: { c: 2 } };
const deepCopy = deepClone(original);
```
:::

### JavaScript 数组 sort 函数的实现原理是什么 ?
JavaScript 数组的 `sort` 函数是基于`快速排序`（QuickSort）和`插入排序`（InsertionSort）混合实现的。<br>
它会根据数组的长度和数据的具体情况动态选择不同的排序算法，以达到最佳性能。<br>
具体来说，对于较小的数组，`sort` 函数会使用插入排序，而对于较大的数组，则会使用快速排序。

#### 补充

##### 快速排序（QuickSort）
快速排序是一种高效的排序算法，通常将选定的“基准值”与其他元素进行比较，然后将数组分成“低于基准值”的一部分和“高于基准值”的一部分，之后递归地对这两部分分别进行排序。<br>
快速排序的平均时间复杂度为 O(n log n)。
##### 插入排序（InsertionSort）
插入排序是一种简单直观的排序算法，适用于较小的数组。<br>
它通过从头到尾扫描数组，将每个元素插入到已排序部分的正确位置。<br>
插入排序的平均时间复杂度为 O(n²)，但对于几乎已排序的数组，它的性能非常出色。
##### 稳定性
JavaScript 的 `sort` 方法默认情况下并不是稳定的。<br>
所谓稳定的排序算法，是指如果待排序的序列中存在两个或两个以上相等的元素，排序后这些元素的相对顺序与排序前保持一致。
##### 自定义比较函数
`sort` 函数可以接收一个可选的自定义比较函数。
```js
array.sort(function(a, b) {
  return a - b; // 升序排序
});
```
如果没有提供比较函数，`sort` 函数会按照字符编码的序列顺序对数组的元素进行排序。<br>
这意味着字符串形式的 '10' 会被认为比 '2' 小，因为在 Unicode 排序中 '1' 比 '2' 小。
##### 性能优化
为了提高性能，现代浏览器会对 `sort` 函数进行优化。<br>
例如，当数组非常小时（如长度小于 10），V8 引擎可能会使用插入排序而不是快速排序。<br>
- 其他优化技巧
  - 在写自定义比较函数时，尽量简化比较逻辑。
  - 尽量避免对大数组进行频繁排序，考虑合并排序等策略。