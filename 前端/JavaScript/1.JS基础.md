## JavaScript基础
主要考察点: 数据类型、作用域、闭包、原型链、事件处理、DOM 操作、定时器、异步编程（如回调函数）以及常见的内置对象和方法。

### JavaScript有哪些数据类型? 它们的区别是什么? 
#### 数据类型
- 原始类型(primitive type)
  - undefined 变量初始化。
    - 一个变量声明后未赋值，则默认值为undefined。
  - null 空的值或一个不存在的对象。
    - null 是一个特殊关键字，它表示“无值”。
  - boolean 布尔值。true 或 false。
    - 用于逻辑判断。
  - number 双精度64位二进制格式的浮点数。
    - 可以表示整数和浮点数。
    - 特殊值：NaN (not a number非数字 )、Infinity (无穷大 )。
  - string 字符序列。
    - 可以用单引号、双引号、反引号表示。
  - symbol 唯一且不可修改的数据类型。
    - 用于对象属性的唯一标识，避免属性名冲突。
  - bigint 任意精度的大整数。
    - 允许超过number 能表示的范围的整数。
- 引用类型(object type)
  - object 对象。 (对象、数组、函数等 )
#### 区别
- 存储区别：
  - 原始类型：存储在栈中 (stack)
    - 值直接保存在变量访问的位置
    - 由于大小固定且频繁使用，存储在栈中具有更高的性能。
  - 引用类型：存储在堆中 (heap)
    - 占用空间较大且大小不固定
    - 变量保存的是实际对象的引用地址 (即指针 )，这些引用地址保存在栈中。
- 赋值方式区别：
  - 原始类型：按值传递 (pass by value)
    - 复制的是值本身。一个变量赋值给另一个变量，两个变量互不影响。
  - 引用类型：按引用传递 (pass by reference)
    - 复制的是引用地址。多个变量引用同一个对象时，一个变量的修改会影响其他变量。
#### 类型检测
- typeof 检查原始类型 typeof 123 === 'number'
  - null 是特殊情况 typeof null 返回 'object'，javascript 设计缺陷 
- instanceof 检查引用类型 [] instanceof
#### 类型转换
- 自动类型转换(隐式类型转换) "" + 123 => "123"
- 显式类型转换 Number()、String()、Boolean()...
#### 堆和栈的区别
- 栈：内存分配效率高、自动管理 (编译器分配和释放 )
- 堆：内存分配效率低、通过开发者手动管理内存 (垃圾回收站机制 )

### 垃圾回收机制
#### 为什么要垃圾回收
- 如果没有垃圾回收机制，适时清理不被引用的值并释放相应的内存空间。JavaScript 解释器将会消耗完系统中所有可用内存，造成系统崩溃。
#### 垃圾回收的核心思路
- 清理掉内存中不再被引用的值
  - 局部变量：在函数调用结束后即是无用的，可以被回收掉；
  - 全局变量：在浏览器卸载页面的时候才会消失。 (由于这个过程消耗较大，所以解释器会按照固定时间周期性的执行回收。 )
#### 垃圾回收的两种方式
- 标记清除 (JS最常用 )
  - 给所有变量增加一个标记：
    如果是进入执行环境 (比如申明变量 )，则标记为“进入环境”
    如果是结束执行环境 (比如执行完相关函数 )，则标记为“离开环境”
  - 去掉“进入环境”的变量标记以及被该变量所引用的变量标记 (比如闭包 )
  - 还存在标记的变量即是需要被清理的变量。
- 引用计数
  - 申明了一个变量，并且将一个引用类型的值赋值给这个变量，那么这变量的引用就加1；
  - 如果这个变量的值又指向另外一个值，或者说这个变量被重新赋值了，那么以上的引用类型的值的引用次数就减1；
  - 如此一来，该引用类型的值的引用次数即为0，垃圾回收器会在运行的时候清理掉引用次数为0的值并释放相应的内存空间；
  - 特别注意：引用计数在代码中存在循环引用时会出现问题
#### 常见的内存泄漏问题
- 意外声明全局变量
```js
function setName(){
  // 此时变量name会被当做window的属性，即全局对象来处理，只要window本身不被清理就不会消失。
	name = 'Jake';
}
```
- 定时器
```js
let name = 'Jake';
setInterval(()=>{
	consolog.log(name);
},100)
```
- 闭包
```js
let outer = function(){
	let name = 'Jake';
	return function(){
		return name;
	}
}
```

### Symbol类型
#### 基本用法与注意点
```js
//后面的括号可以给symbol做上标记便于识别
let name=Symbol('name');
let say=Symbol('say');
let obj= {
  //如果想 使用变量作为对象属性的名称，必须加上中括号，.运算符后面跟着的都是字符串
  [name]: 'lnj',
  [say]: function () {
    console.log('say')
  }
}
obj.name='it666';
obj[Symbol('name')]='it666'
console.log(obj)
```
##### 注意点
- 不能使用new
- 后面括号可以传入一个字符串，只是一个标记，方便我们阅读，没有任何意义
- 类型转化的时候不可转化为数值，只能转化为字符串和布尔值
- 不能做任何运算
- symbol生成的值作为属性或者方法的时候，一定要保存下来，否则后续无法使用
- for循环遍历对象的时候是无法遍历出symbol的属性和方法的
  - 可以通过Object.getOwnPropertySymbols()
#### 三大应用场景
- 避免自定义属性/方法覆盖第三方框架的同名属性/方法
- 消除魔术字符串
- 为对象定义一些非私有的、但又希望只用于内部的方法。
#### 手动实现一个简单的Symbol
```js
(function() {
    var root = this;
    var generateName = (function(){
        var postfix = 0;
        return function(descString){
            postfix++;
            return '@@' + descString + '_' + postfix
        }
    })()
    var SymbolPolyfill = function Symbol(description) {
        // Symbol函数不能使用new命令
        if (this instanceof SymbolPolyfill) throw new TypeError('Symbol is not a constructor');
        // 如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。
        var descString = description === undefined ? undefined : String(description)
        // 当调用 String 方法的时候，如果该对象有 toString 方法，就会调用该 toString 方法，所以我们只要给返回的对象添加一个 toString 方法，即可实现这两个效果。
        var symbol = Object.create({
            toString: function() {
                // 将唯一值添加到__Name__属性保存下来
                return this.__Name__;
            },
            valueOf: function() {
                // 我们无法判断是显式还是隐式的调用，所以这个我们就只能实现一半，要不然实现隐式调用报错，要不然实现显式调用返回该值
                return this;
            }
        })
        // 修改 toString 方法，让它返回一个唯一值
        Object.defineProperties(symbol, {
            '__Description__': {
                value: descString,
                writable: false,
                enumerable: false,
                configurable: false
            },
            '__Name__': { // 用来生成 唯一值的方法
                value: generateName(descString),
                writable: false,
                enumerable: false,
                configurable: false
            }
        });
        // 因为调用该方法，返回的是一个新对象，两个对象之间，只要引用不同，就不会相同
        return symbol;
    }
    var forMap = {};
    // 方法返回一个已登记的 Symbol 类型值的 key。遍历 forMap,查找该值对应的键值即可。
    Object.defineProperties(SymbolPolyfill, {
        'for': {
            value: function(description) {
                var descString = description === undefined ? undefined : String(description)
                return forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);
            },
            writable: true,
            enumerable: false,
            configurable: true
        },
        'keyFor': {
            value: function(symbol) {
                for (var key in forMap) {
                    if (forMap[key] === symbol) return key;
                }
            },
            writable: true,
            enumerable: false,
            configurable: true
        }
    });
    root.SymbolPolyfill = SymbolPolyfill;
})()
```

### 如何判断JavaScript变量是数组? 以及它们的优缺点?
- Object.prototype.toString.call()
  - 优点: 适用于判断各种数据类型，包括数组。不受原型链被修改的影响，因为Object.prototype.toString是原生的方法，不太可能被重写。
  - 缺点: 较其他方法，写法复杂，需要进行字符串切片操作来提取类型信息。
  - 返回值：'[object Array]'
  - Object.prototype.toString.call(obj).slice(8, -1) === 'Array'
  - 优点：
    - 这种方法可以准确地检测出任何对象的数据类型，包括数组。
    - 它不受原型链被修改的影响，因为Object.prototype.toString是原生的方法，不太可能被重写。
  - 缺点：
    - 相对于其他方法，它的写法稍微复杂一些，尤其是当你需要进行字符串切片操作来提取类型信息时。
- 通过原型链做判断
  - 优点：直观的检查对象的原型链是否指向Array.prototype
  - 缺点：非标准属性。当对象的原型链被修改时，可能会导致意外的行为
  - obj.__proto__ === Array.prototype
- 使用es6的Array.isArray()
  - 优点：不受对象原型链修改的影响。简洁明了。
  - 缺点：较旧的JavaScript环境中可能不受支持
  - Array.isArray(obj)
- 使用instanceof
  - 优点：JavaScript中内置的操作符。
  - 缺点：如果页面上下文被更改（例如，有多个框架或窗口），instanceof的结果可能会受到影响，因为它基于当前环境的全局对象来判断。
  - obj instanceof Array
- 使用Array.prototype.isPrototypeOf()
  - 优点：检查Array.prototype是否存在对象的原型链中
  - 缺点：不是最直观或最简洁的方法。如果原型链被修改，这种方法可能会产生误判。
  - Array.prototype.isPrototypeOf(obj) 

### JavaScript中null和undefined的区别?
- 类型检测
```js
console.log(typeof null) //object
console.log(typeof undefined) //undefined
```
- 比较操作
```js
console.log(null == undefined) //true
console.log(null === undefined) //false
```
- 变量赋值
```js
let a = null // JavaScript引擎自动赋予未赋值变量的值
let b = undefined // null是由开发者显式赋值的
```

### 基本类型对应的内置对象，以及他们之间的装箱拆箱操作
#### 内置对象
- 内置对象
  - Object是JS中所有对象的父对象
  - 数据封装类对象：Object Array Boolean Number String
  - 其他对象：Function Math Date RegExp Error
- 特殊的基本包装类型 String Number Boolean
- arguments 只存在函数内部的一个类数组对象
#### 装箱
- 把基本数据类型转换为对应的引用数据类型的操作称为装箱，可以分为隐式装箱和显式装箱。
```js
let a = 'sun'
let b = a.indexOf('s')
//上述代码在后台实际的步骤为
let a = new String('sun')
let b = a.indexOf('s')
a = null
```
#### 拆箱
- 将引用数据类型转换为基本数据类型。通过valueOf()和toString()实现。
```js
let a = new String('sun') //object
let b = new Number(12) //object
a.valueOf() //'sun' string
a.valueOf() //12 number
b.toString() //'sun'string
b.toString() //'12' string
```

### 为什么typeof null 返回object?
- JavaScript 在最初设计时，使用了32位系统。为了优化性能，JavaScript的值被存储为二进制数据，低位用来表示数据类型。
- 对象的类型标识符是 000，而 null 被认为是一个空指针（即零地址），它的二进制表示全是 0，也即 00000000。
- 由于 null 的二进制表示和对象的类型标识符相同，typeof null 结果就被错误地设置为 "object"
- 尽管这个错误很早就被发现，但为了保持向后兼容性，修复这个错误会导致大量现有代码出错。因此，这个行为被保留了下来。

### typeof 和 instanceof 的区别
- 检测类型的范围
  - typeof 检测基本数据类型、函数、未定义类型和symbol类型。
  - instanceof 检测对象的具体类型，检查某个对象是否是某个构造函数的实例。
- 检测基本类型和引用类型
  - typeof 对于基本类型非常有用，对于复杂引用类型(数组、对象字面量)只返回"object"
  - instanceof 只能用于引用类型，不能用于检测基本数据类型。
- 特殊情况
  - typeof null 返回 "object"，这是一个历史遗留问题。
  - instanceof 可以用来检测自定义对象的类型，通过检查原型链确认实例关系。
```js
console.log(typeof undefined) //"undefined"
console.log(typeof 10) //"number"
console.log(typeof true) //"boolean"
console.log(typeof 'sun') //"string"
console.log(typeof {}) //"object"
console.log(typeof []) //"object"
console.log(typeof null) //"object"
console.log(typeof function() {}) //"function"
console.log(typeof Symbol()) //"symbol"
console.log(typeof 10n) //"bigint"

console,log({} instanceof Object) //true
console.log([] instanceof Array) //true
console.log(function(){} instanceof Function) //true
console.log(new Date() instanceof Date) //true
function MyClass() {}
console.log(new MyClass() instanceof MyClass) //true
```

### 可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用
#### 隐式类型转换场景
- 算术运算符：
  - 例如，当你试图将数字与字符串相加时，JavaScript会将数字转换为字符串，然后执行字符串连接。
  - 如 10 + '5' 会得到 '105'，而不是 15。
- 比较运算符：
  - 在比较操作中，如果操作数的类型不同，JavaScript会尝试将它们转换为相同的类型。
  - 例如，'10' == 10 会返回 true，因为字符串 '10' 被转换为了数字 10。 "10" >`"7" => true
- 逻辑运算符：
  - 在逻辑运算中，操作数有时会被转换为布尔值。
  - 例如，在 if ('') { ... } 中，空字符串 '' 会被转换为 false。 if(0) if(1) if(!'') 
- 条件语句和循环：
  - 在 if、while、do...while 和 for 等语句中，条件表达式的结果会被隐式转换为布尔值。
- 字符串与数字之间：
  - "5" - 2 => 3  "5" * "2" => 10
- 函数调用和赋值：
  - 当向期望特定类型参数的函数传递不同类型的参数时，或者将值赋给期望特定类型的变量时，也可能发生隐式转换。
#### 转换原则
- ToPrimitive：
  - 当需要将一个对象转换为原始类型（如字符串、数字或布尔值）时，JavaScript会调用对象的 ToPrimitive 方法。这个方法通常根据期望的原始类型（字符串或数字）和对象的 [@@toPrimitive] 符号属性来确定具体的转换行为。
- ToString：
  - 当需要将一个值转换为字符串时，JavaScript会调用该值的 ToString 方法。这个方法会将该值转换为其对应的字符串表示形式。
- ToNumber：
  - 当需要将一个值转换为数字时，JavaScript会调用该值的 ToNumber 方法。这个方法会根据值的类型和内容来确定具体的转换结果。例如，空字符串会被转换为 0，非空字符串则会被解析为相应的数字（如果可能的话）。
- ToBoolean：
   - 当需要将一个值转换为布尔值时，JavaScript会遵循以下规则：false、0、NaN、null、undefined 和空字符串（''）会被转换为 false，其他所有值都会被转换为 true。
#### 如何避免或巧妙应用
- 避免：
  - 为了避免因隐式类型转换而引发的错误和困惑，你可以尽量保持代码中操作数的类型一致。
  - 在必要时，使用显式类型转换函数（如 Number()、String() 和 Boolean()）来明确指定转换行为。
  - 此外，你还可以使用严格相等运算符（===）来避免比较操作中的隐式类型转换。
- 巧妙应用：
  - 虽然隐式类型转换有时可能会引发问题，但在某些情况下，你也可以利用它来简化代码。
    - 利用逻辑运算符的隐式布尔转换来检查变量的存在性和真值性，如 if (variable) { ... }。
    - 利用算术运算符的隐式类型转换来实现一些特定的功能，如将数字与字符串连接生成特定的文本格式。

### 出现小数精度丢失的原因？如何解决？
#### 精度丢失原因
- JavaScript 中数字的存储遵循 IEEE 754 标准，是以 64 位双精度格式来存储数字的。
- 而二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，剩余的会舍去。
#### 解决方案
- 使用整数进行计算：将数字转成整数进行运算。
- 使用第三方库：decimal.js、bignumber.js等。
- 使用toFixed()方法：将数字转换为字符串，保留指定的小数位数。(0.1 + 0.2).toFixed(1) // '0.3'
#### 最大数字、最大安全数
- 最大数字 Number.MAX_VALUE 1.7976931348623157e+308
- 最大安全数字 Number.MAX_SAFE_INTEGER 9007199254740991
#### 处理大数字的方法
- 字符串逐位相加：
```js
  // 适用于所有JavaScript环境，兼容性强。
  // 实现较为复杂。
  function add(a, b) {
    (a = a.split('')), (b = b.split(''));
    let sum = [],
    go = 0;
    while (a.length || b.length) {
      // 通过pop每次取一个
      let num1 = parseInt(a.pop()) || 0;
      let num2 = parseInt(b.pop()) || 0;
      // 两值相加，如果有进位就 +go
      let tmp = num1 + num2 + go;
      if (tmp > 9) {
        go = 1;
        //取余数
        tmp %= 10;
      } else {
        go = 0;
      }
      //array.unshift(item)表示在数组array的最前面插入
      sum.unshift(tmp);
    }
    if (go) sum.unshift(1);
    return sum.join('');
    } 
```
- BigInt：
```js
  // 代码简洁，易于理解。
  // 在较旧的浏览器中可能不受支持。
  function add(a, b) {
    return (BigInt(a) + BigInt(b)).toString();
  }
```

### 如何让 0.1 + 0.2 !== 0.3 相等 ?
- 使用误差范围
  - Nuumber.EPSILON 表示可接受的最小误差范围
```js
function numberAreEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}
console.log(numberAreEqual(0.1 + 0.2, 0.3)) // true
```
- 使用toFixed()方法
```js
console.log(Number((0.1 + 0.2).toFixed(1)) === 0.3) // true
```
- 使用Number.toPrecision()方法
```js
// 12 是常用的精度位数
console.log(Number((0.1 + 0.2).toPrecision(12)) === 0.3) // true
```

### 如何获取安全的undfined值 ?
- 使用 void 运算对其后的表达式进行求值，然后返回 undefined。
- 因为 void 运算符总是返回 undefined，而且 0 是一个非常短的常量表达式，
- 所以 void 0 是一种简洁且安全的方式获得 undefined 值。

### typeof NaN 的返回值是什么 ?
```js
console.log(typeof NaN) // number
```
#### NaN 的特点
- NaN 是唯一一个不等于自身的值。
```js
console.log(NaN === NaN) // false
console.log(NaN !== NaN) // true
console.log(isNaN(NaN)) // true
console.log(isNaN('a')) // true
```
#### NaN 产生的原因
- 数字运算结果未定义或无法表示 0/0
- 将无法解析为数字的字符串转换为数字 Number("abc")
- 计算结果超出JavaScrip能表示的数字范围 Math.sqrt(-1)

### isNaN 和 Number.isNaN 的区别
- isNaN 函数会先尝试将传入的参数转为数字，然后检查转换后的值是否为 NaN。
- 这意味着它不仅检测NaN本身，还会将那些不能转换为有效数字的值视为 NaN。
```js
// 检查值是否能转为数字
console.log(isNaN(NaN)) // true
console.log(isNaN('a')) // true
console.log(isNaN(undefined)) // true
console.log(isNaN({})) // true
console.log(isNaN([])) // => 0 false
console.log(isNaN('123')) // false
console.log(Number.isNaN(123)) // false
```
- Number.isNaN 函数不会进行类型转换，只会在参数本身是NaN的情况下返回 true。
- 它更为严格，只有传入的值是 NaN 时才会返回 true。
```js
// 检查值本身是否是数字
console.log(Number.isNaN(NaN)) // true
console.log(Number.isNaN('a')) // false
console.log(Number.isNaN(undefined)) // false
console.log(Number.isNaN({})) // false
console.log(Number.isNaN([])) // false
console.log(Number.isNaN('123')) // false
console.log(Number.isNaN(123)) // false
```

### == 操作符的强制类型转换规则是什么 ?
- 强制转换规则
  - null 和 undeinfed 相等自身与对方
  - boolean 和 数字相比 非 0 数字转为 true 0 转为 false
  - 字符串 和 数字相比 字符串转为数字 '0' == false => true
  - 对象 和 原始类型 
    - 如果一个操作符是对象，另一个是原始类型(字符串、数字、布尔值)，对象调用 valueOf/toString方法转为原始类型，再与原始类型对比
  ```js
  // 
  console.log([1,2] == '1,2') // true
  console.log([1] == '1') // true
  console.log({} == '[object Object]') // true
  // 此时 obj 重写了 toString 方法
  const obj = { toString: () => '42' }
  console.log(obj == '42') // true
  const obj1 = { test: () => '42' }
  obj1 == '42' // false
  ```
  - 符号 和 其他 相比永远返回 false
  ```js
  console.log(Symbol() == Symbol()) // false
  console.log(Symbol() == 'symbol') // false
  console.log(Symbol() == false) // false
  ```
- 特殊情况
  - 空字符串会被转为数字0  "" == 0 => true "" == false => true
  - NaN 与任何值都不相等，包括它本身 NaN == NaN => false
  - 0 和 -0 相等
  - 对象转为原始类型时，先调用 valueOf/toSting方法，转为原始类型后再比较

### 其他值到字符串的转换规则是什么 ?
```js
// 基本数据类型到字符串转换规则
console.log(String(null)) // 'null'
console.log(String(undefined)) // 'undefined'
console.log(String(true)) // 'true'
console.log(String(false)) // 'false'
console.log(String(-0)) // '0'
const sym = Symbol('sym')
console.log(String(sym)) // 'Symbol(sym)'
console.log(sym.toString()) // 'Symbol(sym)'
// console.log(sym + "") // TypeError: Cannot convert a Symbol value to a string
// 对象到字符串的转换
console.log(String([1,2])) // '1,2'
console.log(String([])) // ''
console.log(String({})) // '[object Object]'
console.log(String(new Date())) // // 'Sun Aug 01 2023 15:47:29 GMT+0800 (中国标准时间)'
console.log(String(function foo(){})) // 'function foo(){}'
```

### 其他值到数字值的转换规则是什么 ?
```js
// 基本数据类型到数字的转换
console.log(Number(undefined)) // NaN
console.log(Number(null)) // 0
console.log(Number(true)) // 1
console.log(Number(false)) // 0
console.log(Number("hello")) // NaN
console.log(Number(Symbol("desc"))) // TypeError: Cannot convert a Symbol value to a number

// 对象到数字的转换
// 1、将对象转为基本类型值。内部会首先检查该对象是否有 valueOf()方法
// 2、如果 valueOf() 存在并返回基本类型值，则使用该值进行强制类型转换。
// 3、如果没有 valueOf() 方法 或返回的不是基本类型值，则使用 toString() 方法
// 4、如果 toString() 方法也不存在，或返回的不是基本类型值，则报错
let obj1 = {
  valueOf() {
    return 42;
  }
}
console.log(Number(obj1)) // 42
let obj2 = {
  toString() {
    return "42";
  }
}
console.log(Number(obj2)) // 42
let obj3 = {
  valueOf() {
    return {};
  }
  toString() {
    return {};
  }
}
console.log(Number(obj3)) // TypeError: Cannot convert object to primitive value

// 数组的转换
// 1、先转换为字符串，再根据字符串的转换规则进行转换。
// 2、如果数组包含多个元素，结果通常为NaN，因为转换后的字符串包含分隔的元素
console.log(Number([1,2,3])); // NaN
console.log(Number([1])); // 1
console.lohg(Number([])); // 0
console.log(Nuumber(["3.14"])) // 3.14
```

### 其他值到布尔值的转换规则是什么 ?
- undefined、null、false、+0、-0、NaN、"" 转换为 false
- 非空字符串、非零数字 (包括正数和复数)、对象 (包括空对象)、数组(包括空数组)、函数 转换为 true

### JavaScript 中 || 和 && 操作符的返回值是什么 ?
- 逻辑或
  - 1、对第一个操作数进行条件判断。
  - 2、如果第一个操作数是 true, 则返回第一个操作数的值。
  - 3、如果第一个操作数是 false, 则返回第二个操作数的值。
- 逻辑与
  - 1、对第一个操作数进行条件判断。
  - 2、如果第一个操作数的条件判断结果为 false, 则返回第一个操作数的值。
  - 3、如果第一个操作数的条件判断结果为 true, 则返回第二个操作数的值。

### Object.is() 与比较操作符 == 和 === 的区别是什么 ?
- 双等号 (==)
  - 如果类型不同, 会进行类型转换。
  - 将 null 和 undefined 视为相等。
  - 将布尔值转换为数字再进行比较。
  - 将字符串和数字进行比较时，会将字符串转为数字。
  - 对象与原始类型进行比较时，对象会先调用 valueOf()方法转为原始类型，再进行比较。
```js
console.log(2 == '2') // true
console.log(null == undefined) // true
console.log(true == 1) // true
console.log(false == 0) // true
console.log('' == 0) // true
console.log([1,2] == '1,2') // true
```
- 三等号 (===)
  - 如果类型不同, 返回 false
  - 如果类型相同, 再进行值得比较
```js
console.log(2 === '2') // false
console.log(null === undefined) // false
console.log(true === 1) // false
console.log(false === 0) // false
console.log('' === 0) // false
console.log([1,2] === '1,2') // false
```
- Object.is()
  - 如果类型不同, 返回 false
  - 如果类型相同, 再进行值得比较
  - 特殊情况：-0 和 +0 返回 false, NaN 和 NaN 返回 true
#### 区别
- 双等号进行类型转换再比较，适用于宽松相等性判断
- 三等号不进行类型转换，适用于严格相等性判断
- 严格相等运算符 Object.is() 更严格, 适用于精确相等性判断
- Object.is() 与 === 类似, 但是 NaN 和 -0 特殊
- Object.is() === 行为更加可预测
- 由于 === 不需要进行类型转换，所以通常会比 == 的执行速度更快

### 请详细说说 0、+0、-0 这三个有什么区别 ?
- 比较：
  - 在大多数情况下, 0、+0 和 -0 在比较时都被视为相等。
  - 三等号: 0 === +0 和 0 === -0 都会返回 true。
  - Object.is() 可以区分它们。Object.is(0, -0) => false, Object.is(+0, 0) => true。
- 除法：
  - 1 / +0 返回 Infinity, 而 1 / -0 返回 -Infinity。
  - 对于 0, 它通常被视为 +0, 所以 1 / 0 也会返回 Infinity。
- 字符串表示：
  - 当转换为字符串时, 0 和 +0 => "0" -0 => "-0"
- 数学函数：
  - Math.sign() Math.sign(+0) => 0 Math.sign(-0) => -0。

### 什么是JavaScript 中的包装类型 ?
- JavaScript 中, 原始值没有方法或属性, 为了能够使用这些属性和方法
- JavaScript 提供了包装类型, 允许原始值临时拥有对象的属性和方法
- 包装类型: String、Number 和 Boolean
#### 包装类型的行为
- 当你试图访问一个原始值的属性或方法时
- JavaScript 会在后台自动创建一个对应包装对象
- 然后在该对象上调用方法或访问属性
- 一旦操作完成, 这个临时创建的对象就会被销毁
```js
let str = "hello";
console.log(str.length); // 5
console.log(str.toUpperCase()); // "HELLO"
let num = 10;
console.log(num.toFixed(2)); // "10.00"
let bool = true;
console.log(bool.toString()); // "true"
```
#### 原始值和包装对象的区别
```js
let strPrimitive = "hello";
let strObject = new String("hello");
// 本质不同，类型不同
console.log(typeof strPrimitive); // string
console.log(typeof strObject); // object
console.log(strPrimitive === strObject); // false
console.log(strPrimitive == strObject); // true
```

### JavaScript 中 + 操作符什么时候用于字符串的拼接 ?
根据ECMAScript规范, + 操作符的具体行为取决于操作数的类型
- 字符串拼接
- 数值相加
- 对象转为原始值
- 数字和字符串
- 布尔值和字符串

### BigInt
#### 为什么会有BigInt ?
- JavaScript 中的数字类型是基于 IEEE 754 双精度浮点数标准标准实现的。
- 这种实现方式虽然在绝大多数情况下足够, 但在处理非常大的整数时会出现精度问题。
- 为了处理和表示任意精度的整数, JavaScript 引入了 BigInt 类型。
- BigInt 可以表示和操作任意大的整数而不会丢失精度, 从而解决了大整数运算中的问题。
```js
console.log(Number.MAX_SAFE_INTEGER + 1); // 9007199254740992
console.log(Number.MAX_SAFE_INTEGER + 2); // 9007199254740992 (错误)
```
#### BigInt 的优势
- 支持任意大整数: BigInt 可以表示任意大的整数, 而不会丢失精度。
- 专门设计用于整数运算: 与浮点数不同, BigInt 专门用于整数运算, 确保了精度和一致性。
- 与 Number 类型区别明确: BigInt 是一种新的原始数据类型, 与现有的 Number 类型区别明确, 避免了混淆。
- 使用简单: BigInt 类型的使用与 Number 类型相似, 可以直接在数字后添加 n 来创建 BigInt 值。
#### 注意：BigInt 不能与 Number 类型混合使用
```js
const num = 42;
const bigInt = 12345678901234567890n;
console.log(num + bigInt); // 报错: Cannot mix BigInt and other types
// 需要进行显式转换
console.log(BigInt(num) + bigInt); // 12345678901234568742
```

### Object.assign 和对象扩展运算符 ... 有什么区别 ? 是深拷贝还是浅拷贝 ?
- Object.assign 和对象扩展运算符都是浅拷贝
- 对于深拷贝的情况需要额外的处理逻辑来实现
  - 自定义递归函数
  - 使用第三方库如 lodash 的 cloneDeep 函数
- 浅拷贝: 只复制对象的第一层属性, 不会递归复制整个对象结构
#### Object.assign
- 用法: Object.assign(target, ...sources)
  - 用于对象的合并, 将源对象(source)的所有可枚举属性复制到目标对象(target)。
- 深浅拷贝
  - Object.assign 是浅拷贝, 只会递归一级属性
  - 如果源对象的属性值是对象或数组等引用类型, 只复制引用, 不会递归复制整个引用对象
- 覆盖属性
  - 如果多个源对象具有相同的属性, 后续对象的属性会覆盖之前对象的属性
- 返回值
  - 返回目标对象本身, 而不是新创建的对象
```js
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { b: { d: 3 }, e: 4 };
const mergedObj = Object.assign({}, obj1, obj2);
console.log(mergedObj); // { a: 1, b: { d: 3 }, e: 4 }
console.log(obj2.b === mergedObj.b); // true 浅拷贝只复制对象的引用
```
#### 对象扩展运算符 ...
- 用法: { ...obj1, ...obj2 }
  - 创建新的对象字面量
  - 复制现有对象字面量
  - 对象字面量、对象结构赋值、函数参数等
- 深浅拷贝
  - 同 Object.assign
- 覆盖属性
  - 与 Object.assign 类似, 后续对象的属性会覆盖之前对象的属性
- 返回值
  - 对象扩展运算符在对象字面量和对象解构赋值中使用, 会创建一个新的对象
```js
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { b: { d: 3 }, e: 4 };
const mergedObj = { ...obj1, ...obj2 };
console.log(mergedObj); // { a: 1, b: { d: 3 }, e: 4 }
console.log(obj2.b === mergedObj.b); // true 浅拷贝只复制对象的引用
```
#### 区别: Object.assign 合并对象 ... 展开对象

### JavaScript 中 Map 和 Object 有什么区别 ?
#### 区别
- 意外的键
  - Map: 默认情况下不包含任何键, 只包含显示插入的键
  - Object: 有一个原型, 原型链上的键名可能和自己在对象上的设置的键名产生冲突
- 键的类型
  - Map: 键可以是任意值, 包括函数、对象或任意基本类型
  - Object: 键只能是字符串或 Symbols (ES6 新增), 对象的属性名会被自动转换为字符串类型
- 键的顺序
  - Map: key是有序的。因此当迭代的时候, Map 对象以插入的顺序返回键值
  - Object: 对象的属性没有固定的顺序, 属性在内部存储时是无序的
- Size
  - Map: 键值对个数可以轻易地通过 size 属性获取, 大小和性能通常比对象更加可预测, 因为 Map 是专门为存储键值对而设计的数据结构
  - Object: 在绝大多数情况下, 对象的属性数量没有明确的限制
- 迭代
  - Map: 是 iterable 的, 所以可以直接被迭代。
    - 也提供了一些专门用于遍历和操作的方法: 
    - Map.prototype.keys() 返回键名的遍历器
    - Map.prototype.values() 返回键值的遍历器
    - Map.prototype.entries() 返回键值对的遍历器
  - Object: 需要通过 Object.keys(), Object.values(), Object.entries()等方法遍历对象属性
- 性能
  - 在频繁增删键值对的场景下表现更好
  - 在频繁添加和删除键值对的场景下未作出优化
#### 用法
```js
// Object 用法
let obj = {
  name: "John",
  age: 30,
}
obj.city = "New York"; // 添加新属性
console.log(obj); // {name: "John", age: 30, city: "New York"}
delete obj.age; // 删除属性
console.log(obj); // {name: "John", city: "New York"}
// Map 用法
let map = new Map();
map.set("name", "Bob");
map.set(42, "answer");
map.set(obj, "object value");
console.log(map.get(map.get("name"))); // "Bob"
console.log(map.get(42)); // "answer"
console.log(map.get(obj)); // "object value"
map.delete("name"); // 删除键值对
console.log(map.has("name")); // false
```

### JavaScript 中判断数据类型的方式有哪些 ?
#### typeof操作符
typeof 操作符可以用来判断一个变量的基本数据类型(除了null, 它会返回 "object")
```js
typeof 42; // "number"
typeof "hello"; // "string"
typeof true; // "boolean"
typeof undefined; // "undefined"
typeof null // "object" (历史遗留问题, 被错误地归类未对象)
typeof {} // "object"
typeof [] // "object" (数组也是对象的一种特殊形式)
typeof function() {} // "function"
```
#### instanceof 操作符
instanceof 操作符用来判断一个对象是否是某个构造函数的实例, 也可以用来判断是否是某个对象的子实例
```js
let arr = [];
arr instanceof Array; // true
arr instanceof Object; // true (arr 继承自 Object)
```
#### Object.prototype.toString.call() 方法
Object.prototype.toString.call() 方法返回一个表示对象的内部属性 [[Class]] 的字符串, 通过它可以准确判断对象的类型
```js
Object.prototype.toString.call(42); // "[object Number]"
Object.prototype.toString.call("hello"); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function() {}); // "[object Function]"
```
#### Array.isArray() 方法
Array.isArray() 方法用来判断一个对象是否为数组
```js
Array.isArray([]); // true
Array.isArray({}); // false
```
#### typeof 与 instanceof 结合使用
结合typeof 和 instanceof 可以更精准地判断某些复杂类型, 如函数和正则表达式
```js
typeof /regex/; // "object"
/regex/ instanceof RegExp; // true
```

### JavaScript 中有哪些内置对象 ?
- Object: 所有对象的基类, 其他所有对象都继承自它
  - Objet.keys() 返回对象的所有属性名
  - Object.values() 返回对象的所有属性值
  - Object.entries() 返回对象的所有属性名和属性值
- Array: 用于存储有序集合, 并提供了一系列操作方法
  - push() 添加元素到数组末尾
  - pop() 删除数组末尾的元素
  - slice() 返回数组的子集
  - splice() 删除元素并添加新元素
  - sort() 排序数组
  - map() 返回一个新数组, 每个元素为调用函数的结果
  - filter() 返回一个新数组, 包含通过测试的元素
  - reduce() 对数组的每个元素执行函数, 最终返回一个值
  - some() 测试数组中的元素是否通过测试函数
  - every() 测试数组中的所有元素是否都通过测试函数
  - join() 将数组的所有元素连接成一个字符串
- String: 用于处理文本字符串
  - length 属性返回字符串长度
  - indexOf() 返回字符串中指定文本首次出现的索引
  - slice() 返回一个字符串的子集
  - toUpperCase() 返回字符串全大写形式
  - toLowerCase() 返回字符串全小写形式
  - split() 将字符串分割成数组
  - replace() 替换字符串中指定的文本
  - search() 返回指定文本在字符串中首次出现的索引
  - concat() 连接两个字符串
  - localeCompare() 比较两个字符串
  - charAt() 返回指定索引的字符
  - charCodeAt() 返回指定索引字符的 Unicode 值
  - fromCharCode() 将 Unicode 值转换为字符
  - match() 查找字符串中指定的文本
- Number: 用于表示和处理数值的对象, 包括浮点数和整数
  - parseInt() 将字符串转换为整数
  - parseFloat() 将字符串转换为浮点数
  - toFixed() 返回指定小数位数的数字字符串
  - toString() 返回数字的字符串表示
  - valueOf() 返回数字对象的原始值
  - isFinite() 判断是否为有限数
  - isInteger() 判断是否为整数
  - isSafeInteger() 判断是否为安全整数
  - MAX_VALUE 返回 Number 可表示的最大值
  - MIN_VALUE 返回 Number 可表示的最小值
  - POSITIVE_INFINITY 返回正无穷大
  - NEGATIVE_INFINITY 返回负无穷大
  - MAX_SAFE_INTEGER 返回 Number 可表示的最大安全整数
  - MIN_SAFE_INTEGER 返回 Number 可表示的最小安全整数
- Boolean: 用于表示true和false值
- Function: 每个函数都是 Function 类的实例, 并继承自它的属性和方法
  - call() 调用函数, 并指定 this 值和参数
  - apply() 调用函数, 并指定 this 值和参数数组
  - bind() 创建一个新的函数, 该函数在调用时 this 值固定为提供的值
- Date：用于处理日期和时间的对象, 可以精确到毫秒
  - getDate() 返回一个月中的某一天 (1 ~ 31)
  - getDay() 返回一周中的某一天 (0 ~ 6)
  - getFullYear() 返回四位的年份 (yyyy)
  - getMonth() 返回月份 (0 ~ 11)
  - getTime() 返回自 1970 年 1 月 1 日至今的毫秒数
  - getHours() 返回小时 (0 ~ 23)
  - getMinutes() 返回分钟 (0 ~ 59)
  - getSeconds() 返回秒 (0 ~ 59)
  - getMilliseconds() 返回毫秒 (0 ~ 999)
  - setDate() 设置一个月中的某一天 (1 ~ 31)
  - toDateString() 返回日期部分, 以人类可读的格式表示
  - toTimeString() 返回时间部分, 以人类可读的格式表示
- RegExp: 用于处理正则表达式的对象, 强大且灵活
  - exec() 执行正则表达式匹配, 并返回结果数组或 null
  - test() 执行正则表达式匹配, 并返回 true 或 false
  - match() 执行正则表达式匹配, 并返回结果数组或 null
  - replace() 执行正则表达式匹配, 并使用替换字符串替换匹配项
- Math: 提供数字计算的常用工具
  - Math.random() 返回一个随机数 (0 ~ 1)
  - Math.floor() 返回小于等于数字的最大整数
  - Math.ceil() 返回大于等于数字的最小整数
  - Math.round() 返回四舍五入后的整数
  - Math.abs() 返回数字的绝对值
  - Math.max() 返回两个数中较大的一个
  - Math.min() 返回两个数中较小的一个
- JSON: 用于解析和格式化 JSON 格式的数据
  - JSON.stringify() 将 JavaScript 对象转换为 JSON 字符串
  - JSON.parse() 将 JSON 字符串转换为 JavaScript 对象
- Symbol: 一个独特且不可变的基本类型, 常用于对象属性的唯一标识符
- Map: 用于存储键/值对, 且可以记住键值对的插入顺序
  - set() 设置键/值对
  - get() 返回键对应的值
  - has() 判断是否包含某个键
  - delete() 删除键/值对
- Set: 用于存储独一无二的值, 不管是原始值还是对象引用
  - add() 添加值
  - has() 判断是否包含某个值
  - delete() 删除值
  - clear() 清除所有值
- WeakMap: 与 Map 类似, 但键必须是对象, 且该对象引用的键是弱的, 垃圾回收时会自动删除
- WeakSet: 与 Set 类似, 但值必须是对象, 这些对象的优点是弱引用特点
- Promise: 用于处理异步操作对象, 极大简化了异步编程
  - then() 注册回调函数, 处理异步操作的结果
  - catch() 注册错误处理回调函数
  - finally() 注册最终执行回调函数, 无论成功还是失败都会执行
  - 静态
    - Pormise.resolve() 返回一个成功状态的 Promise
    - Promise.reject() 返回一个失败状态的 Promise
    - Promise.all() 返回一个 Promise, 该 Promise 在所有参数 Promise 都成功时才成功
    - Promise.race() 返回一个 Promise, 该 Promise 在任意一个参数 Promise 成功或失败时即可

### JavaScript 中常用的正则表达式有哪些 ?
```js
// 验证邮箱
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
// 验证电话号码
const phoneRegex = /^1[3456789]\d{9}$/;
// 验证邮政编码
const postcodeRegex = /^[1-9]\d{5}$/;
// 验证URL
const urlRegex = /^(https?:\/\/)?([\da-z.-]+)\.([a-z.]{2,6})([/\w .-]*)*\/?$/;
// 验证日期(格式: YYYY-MM-DD)
const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
// 匹配全是数字的字符串
const numberRegex = /^\d+$/;
// 匹配全是字母的字符串
const letterRegex = /^[A-Za-z]+$/;
// 验证码(至少8个字符,且包含至少一个数字和一个字母)
const passwordRegex = /^(?=.*\d)(?=.*[A-Za-z])[\w]{8,}$/;
```
#### 正则表达式基本语法
- `^`表示字符串的开始, `$`表示字符串的结束
- `\d`匹配一个数字, 等价于`[0-9]`
- `\w`匹配一个字母或数字字符, 等价于`[A-Za-z0-9]`
- `+`匹配前面的子表达式一次或多次 例如`\d+`表示至少一个数字
#### 正则表达式常用修饰符
- `i`执行不区分大小写的匹配 例如`/abc/i`可以匹配`AbC`
- `g`执行全局匹配, 找到所有匹配而不是只找到第一个 例如`/b/g`可以匹配字符串中所有的`b`
- `m`执行多行匹配, 例如`/^b/m`可以匹配每一行的第一个`b`
#### 正则表达式的方法
- `test()` 在字符串中测试是否匹配, 返回`true`或`false` 例如`/abc/.test('abcdef')`返回`true`
- `exec()` 在字符串中执行搜索匹配并返回结果数组或`null` 例如`/\d+/g.exec('123abc')`返回`['123']`
- 字符串方法
  - `match()` 返回匹配结果数组或`null` 例如`'abcdef'.match(/b/g)`返回`['b']`
  - `replace()` 替换匹配项, 可以使用正则表达式或字符串作为参数 例如`'abcdef'.replace(/b/g, 'X')`返回`aXcdef`
  - `search()` 返回匹配项的索引或`-1` 例如`'abcdef'.search(/b/)`返回`1`
  - `split()` 根据正则表达式将字符串拆分为子字符串数组 例如`'a,b,c'.split(/,/)`返回`['a', 'b', 'c']`

### 说说你对 JSON 的了解 ?
#### JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式, 易于阅读和编写, 同时也易于机器解析和生成。JSON 格式独立于编程语言, 但其语法于 JavaScript 对象表示语法非常相似。
#### 基本数据类型和结构
- 数字 (number)
- 字符串 (string)
- 布尔值 (boolean): true 或 false
- 数组 (array): 由零个或多个值的顺序列表表示
- 对象 (object): 由键值对组成, 其中键是字符串, 值可以是任何 JSON 数据类型
- null: 表示空值
```json
{
  "name": "John",
  "age": 30,
  "isStudent": true,
  "courses": ["Math", "Physics"],
  "address": {
    "street": "123 Main St",
    "city": "New York",
    "country": "USA"
  }
}
```
#### 使用场景
- 主要用于数据交换, 特别是在 web 浏览器和服务器之间
  - 客户端和服务器之间通过 HTTP 请求进行数据交换, 使用 JSON 作为数据的格式
- 存储配置文件
  - 许多现代应用程序使用 JSON 格式的配置文件, 易于阅读和修改
#### 相比其他格式的优势
- 与 XMLN相比, JSON 更轻量级, 阅读和编写更加简洁
- 支持丰富的数据类型, 如数组和内嵌对象, 直观地表示复杂的数据结构
#### 解析和生成
- JSON.parse() 将 JSON 字符串转换为 JavaScript 对象
- Json.stringify() 将 JavaScript 对象转换为 JSON 字符串
#### 注意事项
- JSON 的键名必须使用双引号括起来, 字符串值也需要使用双引号
- JSON 的表示法不支持对函数、日期对象或正则表达式的直接序列化和反序列化
#### 安全性
- 在解析来自不受信任的数据源 JSON 时, 需小心防范恶意代码注入。
- 可以使用标准库或框架中内置的解析方法来确保安全性和正确性, 而不是使用`eval()`方法解析 JSON

#### JavaScript 脚本延迟加载的方式有哪些 ?
- 使用`async`属性
  - `async` 属性用于让脚本尽可能地异步加载, 不会阻塞HTML解析, 脚本一旦下载完成就立即执行 (不会等待HTML解析完成)
  - 如果有多个`async`脚本, 它们的执行顺序是不确定的
  - 通常用于独立性较高地脚本: 第三方的统计代码、广告代码等
```js
<script async src="example.js"></script>
```
- 使用`defer`属性
  - `defer`属性同样用于脚本延迟加载, 但是它保证了所有`defer`脚本会按照在文档中出现的顺序依次执行,并且是在整个HTML解析完成后执行
  - 因此适合依赖于HTML结构的脚本, 比如需要操作DOM的脚本
```js
<script defer src="example.js"></script>
```
- 动态创建脚本元素
  - 通过JavaScript动态创建`script`标签并插入到文档中
  - 这种方式可以较为灵活地控制脚本的加载和执行时机
  - 常需要某些条件触发时才加载的场景中使用
  - 可以实现按需加载、延迟加载等优化策略
```js
var script = document.createElement('script');
script.src = 'example.js';
script.async = true; // 或者 script.defer = true;
document.head.appendChild(script);
```
- 使用模块化加载工具
  - RequireJS、Webpack、ESM (ECMAScript Modules)、Service Workers (离线加载、缓存) 等
  - 这些工具提供了更为强大的依赖管理和延迟加载功能
  - 适用于大型项目中, 解析代码拆分和按需加载的问题
```js
// Webpack 示例
import('example.js').then(({ default: example }) => {
  // 使用加载的模块
});
```

### 什么是 JavaScript 的类数组对象 ? 如何转化为数组 ?
#### JavaScript 的类数组对象 (Array-like object) 指的是具有类似数组特性, 但并不是数组对象。它们通常具备`length`属性和按索引存储的元素。(如`arguments`对象、DOM方法返回的集合如`NodeList`)
#### 将类数组对象转换为真正的数组
- 使用`Array.prototype.slice.call()`方法:
```js
const arrayLike = { 0: 'a', 1: 'b', length: 2 };
const realArray = Array.prototype.slice.call(arrayLike); // ['a', 'b']
```
- 使用`Array.from()`(ES6引入)方法:
```js
const arrayLike = { 0: 'a', 1: 'b', length: 2 };
const realArray = Array.from(arrayLike); // ['a', 'b']
```
- 使用展开运算符(spread operator)`...`:
```js
const arrayLike = { 0: 'a', 1: 'b', length: 2 };
const realArray = [...arrayLike]; // ['a', 'b']
```
#### 类数组与数组的主要区别: 类数组对象没有数组的方法, 如`push`, `pop`, `shift`, `unshift`, `join`等。
转换为数组后, 可以更方便地使用这些方法对数据进行操作
- `Array.prototype.slice.call()`: 这种方法在 ES6 之前非常常见, 利用`slice`方法将类数组对象切片成真正的数组。
  - 书写复杂、效率稍低
- `Array.from()`: ES6 引入的新方法。可接受第二个参数用来处理每一个元素
  - 简洁高效
- 展开运算符(spread operator): ES6 新增的语法糖
  - 最为简洁且可读性强, 但需要确保类数组对象的结构完整 (包括`length`属性)

### JavaScript 的数组有哪些原生方法 ?
- 数组和字符串的转换方法: toString()、join()、toLocaleString()、valueOf()
- 数组尾部操作方法: push()、pop()
- 数组头部操作方法: shift()、unshift()
- 数组连接方法: concat() 不影响原数组
- 数组排序方法: reverse()、sort()
- forEach() 遍历数组每个元素 map() 创建新数组, 其结果由回调函数处理后的值组成
- find() 和 findIndex() 返回第一个符合条件的元素和索引
- some() 和 every() 判断数组中是否有一个元素或所有元素符合条件 返回布尔值
- flat() 和 flatMap() 创建一个新数组, 其中所有子数组元素递归地连接到指定地深度 [1, [1, 3]].flat() => [1,2,3] [1, [1, 3]].flatMap(x => [x * 2]) => [2,4]

### 为什么 JavaScript 函数的 arguments 参数是类数组而不是数组 ? 如何遍历类数组 ?
#### arguments 参数是类数组而不是数组
- 历史原因
arguments 对象是在 JavaScript 语言早起引入的, 当时并没有数组对象。为了方便处理函数参数, 引入了 arguments 对象
- 性能考虑
将 arguments 实现为真正的数组可能会带来一些性能开销。类数组对象可以更高效地实现某些操作。
arguments 是一个对象, 它的属性是从 0 开始依次递增的数字, 还有callee和length等属性, 与数组相似; 但是它却没有数组常见的方法属性, 如forEach、reduce等, 所以叫它们类数组
#### 遍历类数组
- 将数组的方法应用到类数组上, 这时候就可以使用`call`和`apply`方法
```js
function foo() {
  Array.prototype.forEach.call(arguments, a => console.log(a));
}
```
- 使用Array.from()方法
```js
function foo() {
  const arrArgs = Array.from(arguments);
  arrArgs.forEach(a => console.log(a));
}
```
- 使用展开运算符
```js
function foo() {
  const arrArgs = [...arguments];
  arrArgs.forEach(a => console.log(a));
}
```
#### 拓展
- 在现代 JavaScript 中, 我们通常推荐使用剩余参数 (rest parameters) 替代 arguments
- 剩余参数提供了一个真正的数组, 更易于使用
```js
function example(...args) {
  args.forEach(a => console.log(a));
}
```

### 什么是 DOM 和 BOM ?
#### DOM (Document Object Model) 文档对象模型, 是针对 HTML 和 XML 文档的 API (应用程序编程接口)。DOM 描绘了一个层次化的节点树,允许开发人员添加、移除和修改页面的某一部分。
简单来说, 它就是把网页内容转换成 JavaScript 可以操作的对象。
- DOM 的主要特点
  - 它将文档解析为一个由节点和对象组成的结构集合
  - 它定义了文档的结构, 以及如何访问和操作文档
- DOM 的作用
  - 允许程序和脚本动态地访问和更新文档的内容、结构和样式
  - 提供了一种标准化的方式来操作网页内容
- 常见的DOM操作
  - 获取元素: document.getElementById()、getElementsByClassName()、querySelector()
  - 创建元素: document.createElement()、appendChild()、insertBefore()
  - 修改元素属性: element.setAttribute()、removeAttribute(), 也可以element.className = "class-name"
  - 修改元素内容: element.innerHTML 可以解析 HTML 标签、element.textContent 只会识别并处理纯文本
  - 修改元素样式: element.style.property
  - 添加或删除元素: parentNode.appendChild()、removeChild()、insertBefore()、replaceChild()
  - 事件监听: element.addEventListener()
  - 一些进阶操作：
    - 克隆节点：使用 element.cloneNode() 方法可以复制节点。
    - 查找父节点/子节点：通过 element.parentNode, element.childNodes, element.firstChild, element.lastChild 等可以遍历不同层次的节点。
    - 获取或设置样式：可以通过 element.style 对象来操作内联样式，或者通过 window.getComputedStyle() 获取元素的计算样式。
    - 处理样式类名：使用 classList 属性可以方便地添加、删除、切换和判断类名，例如 element.classList.add('new-class')。
#### BOM (Browser Object Model) 浏览器对象模型, 是针对浏览器的 API。BOM 提供了独立于内容而与浏览器窗口进行交互的对象。由于 BOM 主要涉及控制浏览器、与用户交互等操作, 因此它也被称为浏览器对象模型。
简单来说, 它就是浏览器提供的用于操作浏览器的接口。
- BOM 的主要组成部分
  - window 对象: JavaScript 层级中的顶层对象, 表示浏览器窗口
  - navigator 对象: 包含有关浏览器的信息
  - location 对象: 包含有关当前 URL 的信息
  - screen 对象: 包含有关客户端显示屏幕的信息
  - history 对象: 包含浏览器的历史记录
- BOM 的作用
  - 提供了与浏览器交互的方法和接口
  - 允许 JavaScript 与浏览器对话
- 常见的 BOM 操作
  - 打开新窗口: window.open()
  - 移动、调整窗口大小: window.moveTo()、 window.resizeTo()
  - 导航到其他URL: winodw.location.href = ""
  - 获取浏览器信息: navigator.userAgent
  - 操作浏览历史: history.back() hisotry.forward()
#### DOM 和 BOM 的主要区别
- DOM 主要处理网页内容, 而 BOM 主要处理浏览器窗口和功能
- DOM 是 W3C (World Wide Web Consortium) 组织推荐的标准, 而 BOM 没有相关标准
- DOM 可以在任何支持 XML 的环境中使用, 而 BOM 只能在浏览器环境中使用

### escape、encodeURI 和 encodeURIComponent 有什么区别 ?
都是处理URL编码问题的函数
#### escape()
- escape 已经废弃, 可能在维护旧代码时遇到它
- 不能正确处理非 ASCII 字符
- 主要用于对字符串进行编码。它会将所有非字母数字字符转换为它们的十六进制转义序列, 除了@ * _ + - . / 之外
```js
console.log(escape("Hello World! @*_+-./")); 
// Hello%20World%21%20@*_+-./
```
#### encodeURI()
- 用于编码完整的 URI
- 可以正确处理非 ASCII 字符
- 可以编码所有对 URI 有特殊含义的字符, 除了 , / ? : @ & = + $ # 之外
```js
console.log(encodeURI("https://example.com/path?name=张三&age=18")); 
// https://example.com/path?name=%E5%BC%A0%E4%B8%89&age=18
```
#### encoedURIComponent()
- 用于编码 URI 的组成部分
- 可以正确处理非 ASCII 字符
- 它编码对所有 URI 有特殊含义的字符
```js
console.log(encoedURIComponent("https://example.com/path?name=张三&age=18")) 
// https%3A%2F%2Fexample.com%2Fpath%3Fname%3D%E5%BC%A0%E4%B8
```

### 什么是 AJAX ? 如何实现 AJAX 请求 ?
AJAX 是 Asynchronous JavaScript and XML 的缩写。
指的是通过 JavaScript 的异步通信, 从服务器获取 XML 文档从中提取数据, 再更新当前网页的对应部分, 而不用刷新整个网页。
创建AJAX请求的步骤:
- 创建一个 XMLHttpRequest 对象
- 在这个对象上使用open方法创建一个HTTP请求, open方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息
- 在发起请求前, 可以为这个对象添加一些信息和监听函数
  - 比如说可以通过 setRequestHeader 方法来为请求添加头信息
  - 还可以为这个对象添加一个状态监听函数
  - 一个XMLHttpRequest对象一共有5个状态, 当它的状态变化时会触发onreadystatechange事件, 可以通过设置监听函数, 来处理请求成功后的结果
  - 当对象的readySate属性变为4时, 代表服务器返回的数据接收完成, 这个时候可以通过判断请求的状态, 如果状态是2xx 或者 304则代表返回正常。这个时候可以通过 response 中的数据来对页面进行更新了
- 当对象的属性和监听函数设置完成后, 最后调用 sent 方法来向服务器发起请求, 可以传入参数作为发送的数据体
```js
function makeAjaxRequest(url, method, data, callback) {
  const xhr = new XMLHttpRequest();
  
  xhr.onreadystatechange = function() {
    if (xhr.readyState === XMLHttpRequest.DONE) {
      if (xhr.status === 200) {
        callback(null, xhr.responseText);
      } else {
        callback(new Error('请求失败: ' + xhr.status));
      }
    }
  };
  
  xhr.open(method, url, true);
  
  if (method.toUpperCase() === 'POST') {
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(JSON.stringify(data));
  } else {
    xhr.send();
  }
}

// 使用示例
makeAjaxRequest('https://api.example.com/data', 'GET', null, function(error, response) {
  if (error) {
    console.error('出错了:', error);
  } else {
    console.log('收到响应:', response);
  }
});

```
使用Fetch API实现 AJAX 请求（更现代的方法）：
```js
function makeAjaxRequest(url, method, data) {
  const options = {
    method: method,
    headers: {
      'Content-Type': 'application/json'
    }
  };

  if (method.toUpperCase() !== 'GET' && data) {
    options.body = JSON.stringify(data);
  }

  return fetch(url, options)
    .then(response => {
      if (!response.ok) {
        throw new Error('请求失败: ' + response.status);
      }
      return response.json();
    });
}

// 使用示例
makeAjaxRequest('https://api.example.com/data', 'GET')
  .then(data => console.log('收到数据:', data))
  .catch(error => console.error('出错了:', error));
```

### use strict 是什么意思 ? 使用它有什么区别 ?
#### 含义
"use strict" 是一个字符串声明，放在脚本或函数的开头，用来指定代码应该在严格模式下执行。
```js
"use strict";
// 后面的代码会在严格模式下执行
```
#### 严格模式的主要作用
严格模式主要是为了捕获一些常见的编程错误，并防止使用一些可能在未来版本中定义的语法。
#### 使用 "use strict" 的主要区别
```js
"use strict";
// 1、变量必须声明后再使用
x = 3.14; // 错误：x 未定义

// 2、禁止使用 with 语句
with (Math){x = cos(2)}; // 语法错误

// 3、创建 eval 作用域
// 在严格模式下，eval() 中的代码会在自己的作用域中执行，而不是在当前作用域中。

// 4、禁止 this 关键字指向全局对象
function f(){
  return this;
}
f(); // 返回 undefined，而不是全局对象

// 5、函数参数不能有重名
function sum(a, a, c){ // 语法错误
    return a + a + c;
}

// 6、禁止八进制数字语法
var sum = 015 + 197 + 142; // 语法错误

// 7、禁止对只读属性赋值
var obj = {};
Object.defineProperty(obj, "x", { value: 0, writable: false });
obj.x = 3.14; // 抛出错误

// 8、禁止删除不可删除的属性
delete Object.prototype; // 抛出错误
```
#### 使用 "use strict" 的好处
- 消除 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为。
- 消除代码运行的一些不安全之处，保证代码运行的安全。
- 提高编译器效率，增加运行速度。
- 为未来新版本的 JavaScript 做好铺垫。
#### 拓展
在类和模块中，严格模式会自动启用。使用 "use strict" 可以帮助我们写出更加规范、安全的代码，并且可以在开发阶段就发现一些潜在的问题。在现代 JavaScript 开发中，特别是使用 ES6 模块或类时，严格模式已经成为默认行为。

### JavaScript 如何判断一个对象是否属于某个类
```js
// 1、instanceof 运算符
// 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
class Animal {}
class Dog extends Animal {}
const dog = new Dog();
console.log(dog instanceof Dog);     // true
console.log(dog instanceof Animal);  // true
console.log(dog instanceof Object);  // true
// 2、constructor 属性
// 每个对象都有一个 constructor 属性，指向创建该对象的构造函数。
console.log(dog.constructor === Dog);  // true
// 3、Object.prototype.isPrototypeOf() 方法
// 测试一个对象是否存在于另一个对象的原型链上。
console.log(Dog.prototype.isPrototypeOf(dog));    // true
console.log(Animal.prototype.isPrototypeOf(dog)); // true
// 4、Object.getPrototypeOf() 方法
// 这个方法返回指定对象的原型。
console.log(Object.getPrototypeOf(dog) === Dog.prototype);  // true
// 5、自定义类型检查函数
// 有时候，我们可能需要更精确的类型检查。这时可以自定义一个函数：
function isDog(obj) {
  return obj && typeof obj === 'object' && obj.constructor === Dog;
}
console.log(isDog(dog));  // true
// 6、Symbol.hasInstance
// ES6 引入了 Symbol.hasInstance 方法，允许类自定义 instanceof 的行为。
class MyClass {
  static [Symbol.hasInstance](instance) {
    return Array.isArray(instance);
  }
}
console.log([] instanceof MyClass);  // true
```
这些方法各有优缺点：
- instanceof 和 isPrototypeOf() 可以检查整个原型链，但可能会受到原型链被修改的影响。
- constructor 属性可以被重写，因此不总是可靠。
- Object.getPrototypeOf() 更可靠，但只检查直接原型。
- 自定义函数可以提供最精确的检查，但需要为每个类型单独实现。
在实际开发中，选择哪种方法取决于具体的需求和上下文。通常，instanceof 是最常用的方法，因为它简单直观，并且能够处理继承关系。

### ajax、axios、fetch 的区别是什么 ?
#### Ajax (Asynchronous JavaScript and XML)
Ajax 不是一种单一的技术，而是一种使用现有技术集合的方法。它最常见的实现是使用 XMLHttpRequest (XHR) 对象。
- 特点: 
  - 是最早的异步请求解决方案
  - 可以与服务器交换数据并更新部分网页内容，而无需重新加载整个页面
  - 使用回调函数处理响应
  - 不支持 Promise
```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);
xhr.onreadystatechange = function() {
  if (xhr.readyState == 4 && xhr.status == 200) {
    console.log(xhr.responseText);
  }
};
xhr.send();
```
#### Fetch
Fetch 是较新的 API，旨在替代 XMLHttpRequest。它是基于 Promise 的。
- 特点: 
  - 语法更简洁，使用起来更加直观
  - 基于 Promise，支持 async/await
  - 原生支持，不需要额外的库
  - 不会自动拒绝 HTTP 错误状态
```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
```
#### Axios
Axios 是一个基于 Promise 的 HTTP 客户端，可以用于浏览器和 Node.js。
- 特点:
  - 支持浏览器和 Node.js
  - 自动转换 JSON 数据
  - 可以拦截请求和响应
  - 可以取消请求
  - 客户端支持防御 XSRF (跨站请求伪造)
```js
axios.get('https://api.example.com/data')
  .then(response => {
    console.log(response.data);
  })
  .catch(error => {
    console.error('Error:', error);
  });
```
#### 主要区别
- 语法和使用方式：
  - Ajax 使用回调函数
  - Fetch 使用 Promise
  - Axios 也使用 Promise，但提供了更简洁的 API
- 错误处理：
  - Fetch 不会自动抛出错误，即使响应状态为 404 或 500
  - Axios 会在响应状态不在 2xx 范围内时自动抛出错误
- 请求取消：
  - Fetch 需要使用 AbortController
  - Axios 提供了取消请求的方法
- 浏览器支持
  - Ajax (XMLHttpRequest) 支持所有现代浏览器
  - Fetch 不支持一些旧版浏览器（如 IE11）
  - Axios 通过适当的 polyfill 可以支持更广泛的浏览器
- 功能丰富度：
  - Axios 提供了更多的功能，如拦截器、自动转换 JSON 等

### JavaScript 数组的遍历方法有哪些 ？
```js
// 1、for 循环
// for循环是最传统的方法，我们可以通过索引来访问数组的每个元素，而且可以提前终止循环
const arr = [1, 2, 3, 4, 5];
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
// 2、forEach 循环
// 这是一个更现代、更简洁的方法。它为每个数组元素执行一次回调函数
arr.forEach((item, index) => {
  console.log(item, index);
});
// 3、ES6 引入的新语法 for...of
// for...of 遍历具有 Iterator 迭代器的对象的属性，可以直接遍历数组的值，不能遍历普通的 obj 对象，将异步循环变成同步循环
for (const item of arr) {
  console.log(item);
}
// 4、map
// 这个方法会创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后的返回值，可链式调用
const newArr = arr.map(item => item * 2); // [2, 4, 6, 8, 10]
// 5、filter
// 过滤数组，返回包含符合条件的元素的数组，可链式调用
const evenNumbers = arr.filter(item => item % 2 === 0);  // [2, 4]
// 6、reduce 和 reduceRight
const sum = arr.reduce((acc, cur) => acc + cur, 0); // 制定了初始值位0 
// acc: 0 cur: 1
// acc: 1 cur: 2
// acc: 3 cur: 3
// acc: 6 cur: 4
// acc: 10 cur: 5
const sum = arr.reduceRight((acc, cur) => acc + cur, 0); // 从数组的最后一项开始，向前遍历到第一项
// 7、some 和 every
const hasEven = arr.some(item => item % 2 === 0);
const allPositive = arr.every(item => item > 0);
// some() 测试数组中是不是至少有一个元素通过了指定函数的测试
// every() 测试一个数组内的所有元素是否都能通过某个指定函数的测试
```

### JavaScript 的 forEach 和 map 方法有什么区别 ?
- 返回值区别
  - forEach 方法没有返回值，它只是对数组的每个元素执行一次对应的函数。
  - map 方法会返回一个新数组，这个新数组由原数组中的每个元素经过指定函数处理后的值组成。
- 使用场景区别
  - forEach 主要用于执行副作用（例如修改原数组、打印元素、修改外部状态等）。
  - map 主要用于将原数组的每个元素转换成一个新的元素，并返回包含转换后元素的新数组。（例如，将数组中的所有数字翻倍）
```js
const numbers = [1, 2, 3, 4, 5];
// 1、forEach
numbers.forEach(num => console.log(num * 2));
// 输出: 2, 4, 6, 8, 10
// 但 numbers 数组保持不变
// 2、map
const doubledNumbers = numbers.map(num => num * 2);
console.log(doubledNumbers);
// 输出: [2, 4, 6, 8, 10]
// numbers 数组仍然保持不变，doubledNumbers 是一个新数组
```

### mouseover 和 mouseenter 事件的区别是什么 ?
一句话概括： mouseover 会冒泡，mouseenter 不会。
- 触发条件不同
  - mouseover 在鼠标指针进入元素或元素的子元素时会触发，即当鼠标指针从元素外部移入元素边界时触发
  - mouseenter 只在鼠标指针进入元素时触发，不会在进入元素的子元素时触发
- 事件冒泡不同
  - mouseover 会冒泡，即当鼠标指针从子元素移出到父元素时也会触发
  - mouseenter 不会冒泡，即只在进入元素时触发，不影响其它元素的事件
- 使用场景
  - 如果希望在鼠标进入元素及其子元素时都触发事件，可以使用 mouseover
  - 如果只想在鼠标进入元素本身时触发事件，可以使用 mouseenter
```js
const parent = document.getElementById('parent');
const child = document.getElementById('child');

parent.addEventListener('mouseover', () => {
  console.log('Parent mouseover');
});

parent.addEventListener('mouseenter', () => {
  console.log('Parent mouseenter');
});

child.addEventListener('mouseover', () => {
  console.log('Child mouseover');
});

child.addEventListener('mouseenter', () => {
  console.log('Child mouseenter');
});
```
当鼠标从父元素移动到子元素时：
mouseover 会在子元素和父元素上都触发
mouseenter 只会在最初进入父元素时触发一次

### JavaScript 中 substring 和 substr 函数的区别是什么 ?
#### 参数含义 -最主要的区别
```js
// - substring(startIndex, endIndex) 方法
//   - startIndex：开始提取字符的位置
//   - endIndex：结束提取字符的位置（不包括该位置的字符）
// - substr(startIndex, length) 方法
//   - startIndex：开始提取字符的位置
//   - length：要提取的字符数
let str = "Hello, World!";
console.log(str.substring(-3)); // 输出: "Hello, World!"
console.log(str.substr(-3));    // 输出: "ld!"
```
#### 负值参数的处理和参数顺序
```js
// - 负值参数的处理
//   - substring 方法会将负值参数都转换为 0
//   - substr 方法允许第一个参数为负值，它会从字符串的末尾开始计数
// - 参数顺序
//   - substring 方法会自动调整参数的顺序，使得 startIndex 总是小于等于 endIndex
//   - 而 substr 不会这样做
let str = "Hello, World!";
console.log(str.substring(5, 2)); // 输出: "llo"
console.log(str.substr(5, 2));    // 输出: ", "
```
#### 浏览器兼容性和未来发展
- substring 方法在所有现代浏览器中都得到了很好的支持。
- 而 substr 方法虽然目前仍被广泛支持，但已经被 MDN 标记为废弃（deprecated）。
- 这意味着在未来的 JavaScript 版本中，substr 可能会被移除。
#### 拓展
1）可以更现代的 slice 方法来平替 substring 方法

### JavaScript 数组的 map 和 forEach 函数中能否通过 break 等语法结束循环 ?
在 JavaScript 中，map 和 forEach 方法中是不能直接使用 break 或 continue 语句来结束循环的。这是因为 map 和 forEach 是高阶函数,它们的设计初衷就是要遍历整个数组。
```js
// 1、forEach 中抛出一个自定义异常，然后在异常捕获块中终止循环
try {
  [1, 2, 3, 4, 5].forEach(item => {
    if (item > 3) throw new Error("Break");
    console.log(item);
  });
} catch (e) {
  if (e.message !== "Break") throw e;
}
// 这种方法虽然可以达到目的,但我个人不太推荐,因为使用异常来控制程序流程不是一个好习惯

// 2、使用 Array.prototype.some() 或 Array.prototype.every()
[1, 2, 3, 4, 5].some(item => {
  if (item > 3) return true;
  console.log(item);
  return false;
});
// every 方法也可以，这两个方法允许你在满足某个条件时提前结束循环，这种方法更加优雅,也更符合函数式编程的思想

// 3、使用普通的 for 循环
for (let item of [1, 2, 3, 4, 5]) {
  if (item > 3) break;
  console.log(item);
}
// 这种方法虽然不够简洁,但是在需要更细粒度控制循环的情况下很有用

// 4、Array.prototype.reduce()
[1, 2, 3, 4, 5].reduce((acc, item) => {
  if (acc.break) return acc;
  if (item > 3) return { break: true };
  console.log(item);
  return acc;
}, {});
// 这种方法比较灵活,可以根据需要存储和传递更多的信息
```

### JavaScript 中如何合并对象 ?
```js
// 1、使用展开运算符（Spread Operator）
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };
const mergedObj = { ...obj1, ...obj2 };
console.log(mergedObj); // { a: 1, b: 3, c: 4 }
// 这种方法进行的是浅拷贝，如果有重复的属性，后面对象的属性会覆盖前面的

// 2、使用Object.assign()
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };
const mergedObj = Object.assign({}, obj1, obj2);
console.log(mergedObj); // { a: 1, b: 3, c: 4 }
// 这个方法也是浅拷贝，同样后面的对象属性会覆盖前面的

// 3、使用递归进行深度合并
function deepMerge(target, source) {
  for (let key in source) {
    if (source[key] instanceof Object && target[key] instanceof Object) {
      target[key] = deepMerge(Object.assign({}, target[key]), source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}
const obj1 = { a: { x: 1, y: 2 }, b: 2 };
const obj2 = { a: { y: 3, z: 4 }, c: 3 };
const mergedObj = deepMerge({}, obj1, obj2);
console.log(mergedObj); // { a: { x: 1, y: 3, z: 4 }, b: 2, c: 3 }
// 这种方法可以处理嵌套对象，但要注意可能会有性能问题，特别是对于大型复杂对象

// 4、在实际开发中，会使用像 Lodash 这样的工具库，它提供了更强大和灵活的对象合并功能：
const _ = require('lodash');
const obj1 = { a: { x: 1, y: 2 }, b: 2 };
const obj2 = { a: { y: 3, z: 4 }, c: 3 };
const mergedObj = _.merge({}, obj1, obj2);
console.log(mergedObj); // { a: { x: 1, y: 3, z: 4 }, b: 2, c: 3 }
// Lodash 的 merge 方法可以进行深度合并，而且处理了很多边界情况
```

### JavaScript 如何判断一个对象是不是空对象 ?
```js
// 1、使用 Object.keys()
function isEmptyObject(obj) {
  // 但是在使用这个方法之前，我们需要对传入的对象进行 判空
  return obj && typeof obj === 'object' && Object.keys(obj).length === 0;
}
let emptyObj = {};
console.log(isEmptyObject(emptyObj)); // true
let nonEmptyObj = { key: 'value' };
console.log(isEmptyObject(nonEmptyObj)); // false
// Object.keys() 返回一个包含对象所有可枚举属性的数组。如果这个数组的长度为 0，那么对象就是空的

// 2、使用 for...in 循环
// 兼容较老的浏览器
function isEmptyObject(obj) {
  // 遍历对象的所有可枚举属性。
  for (let prop in obj) {
    // 如果找到任何一个属性，就说明对象不为空
    if (Object.hasOwn(obj, prop)) {
      return false;
    }
  }
  return true;
}

// 3、使用 JSON.stringify()
function isEmptyObject(obj) {
  return JSON.stringify(obj) === '{}';
}
// 这个方法可能会有一些边界情况，比如对象中包含 undefined、函数等值时可能会出现问题

// 4、使用 Object.getOwnPropertyNames()
function isEmptyObject(obj) {
  return Object.getOwnPropertyNames(obj).length === 0;
}
// 这个方法比 Object.keys() 更严格，因为它会检查所有属性，而不仅仅是可枚举属性

// 注意：这些方法都不能检测对象的原型链。 
// 如果你需要考虑原型链上的属性，可能需要自己实现一个递归函数。
```

### JavaScript 的 splice 和 slice 函数会改变原数组吗 ?
```js
// 1、splice() 方法 会改变原数组
// 可以在数组中添加、删除或替换元素，并返回被删除的元素
const arr = [1, 2, 3, 4, 5];
const removed = arr.splice(2, 2); // 从索引2开始删除2个元素
console.log(arr); // 输出: [1, 2, 5]
console.log(removed); // 输出: [3, 4]
const arr1 = [1, 2, 3, 4, 5];
arr1.splice(2, 2, 'a', 'b');
console.log(arr1); // 输出: [1, 2, 'a', 'b', 5]
const arr2 = [1, 2, 3, 4, 5];
arr2.splice(2, 0, 'a', 'b'); // 插入元素
console.log(arr2); // 输出: [1, 2, 'a', 'b', 3, 4, 5]

// 2、slice() 方法 不会改变原数组
// 从原数组中返回指定开始和结束位置的元素组成的新数组，包含原数组的一部分浅拷贝。
const arr = [1, 2, 3, 4, 5];
const sliced = arr.slice(1, 3); // 从索引1开始到索引3结束（不包括索引3）
console.log(arr); // 输出: [1, 2, 3, 4, 5]
console.log(sliced); // 输出: [2, 3]
```

### JavaScript 中怎么删除数组最后一个元素 ?
```js
// 1、使用 pop() 方法
// 删除数组的最后一个元素，返回被删除的元素。
// 性能非常高效
let fruits = ['apple', 'banana', 'orange'];
let lastFruit = fruits.pop();
console.log(lastFruit); // 输出: 'orange'
console.log(fruits); // 输出: ['apple', 'banana']
// pop() 方法的优点是简单直观，而且它会直接修改原数组
// pop() 方法处理空数组时要小心，因为它返回 undefined

// 2、使用 splice() 方法
// 更加灵活
// 第一个参数 -1 表示从数组末尾开始，第二个参数 1 表示删除一个元素
let removedFruits = fruits.splice(-1, 1);
console.log(removedFruits); // 输出: ['orange']
console.log(fruits); // 输出: ['apple', 'banana']

// 3、使用 slice() 方法
// 如果不想修改原数组，可以使用 slice() 方法创建一个新数组
// 会有额外的内存开销
let newFruits = fruits.slice(0, -1);
console.log(newFruits); // 输出: ['apple', 'banana']
console.log(fruits); // 输出: ['apple', 'banana', 'orange']

// 4、使用数组长度
// 简单高效、阅读性稍微差
fruits.length = fruits.length - 1;
console.log(fruits); // 输出: ['apple', 'banana']
```

### 如何判断网页元素是否到达可视区域 ?
通常用于实现懒加载、无限滚动或者触发动画等场景中
```js
// 1、使用 Intersection Observer API
// 既高效又简单、可以异步地观察目标元素与其祖先元素或视口的交叉状态
// 性能好，不会阻塞主线程，而且使用起来相对简单
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('元素进入可视区域');
      // 在这里执行你的逻辑
    }
  });
});
const target = document.querySelector('#your-element');
observer.observe(target);

// 2、getBoundingClientRect() 方法
// 更精确的控制、兼容旧版浏览器
// 这个方法返回元素的大小及其相对于视口的位置
// 如果在滚动事件中频繁调用，可能会影响性能
// 可以使用节流（throttle）或防抖（debounce）技术来限制函数的调用频率，以避免过度消耗性能。
function isElementInViewport(el) {
  const rect = el.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}
// 使用
const element = document.querySelector('#your-element');
if (isElementInViewport(element)) {
  console.log('元素在可视区域内');
}

// 3、使用 Element.checkVisibility() 方法
// 相对较新的 API，可以直接检查元素是否可见
// 需要注意浏览器兼容性问题
const element = document.querySelector('#your-element');
if (element.checkVisibility()) {
  console.log('元素可见');
}
// 这个方法还可以接受一个选项对象，用于进行更细粒度的检查
element.checkVisibility({
  checkOpacity: true,  // 检查 opacity 是否为 0
  checkVisibilityCSS: true  // 检查 visibility CSS 属性
});
```

### JavaScript 操作数组元素的方法有哪些 ?
#### 添加
```js
// push(): 在数组末尾添加一个或多个元素。
// unshift(): 在数组开头添加一个或多个元素。
// splice(): 在指定位置添加元素。
const arr = [1, 2, 3];
arr.push(4); // [1, 2, 3, 4]
arr.unshift(0); // [0, 1, 2, 3, 4]
arr.splice(2, 0, 1.5); // [0, 1, 1.5, 2, 3, 4]
```
#### 修改
```js
// fill(): 用一个固定值填充数组中从起始索引到终止索引的全部元素。
// copyWithin(): 将数组中的一部分复制到同一数组中的另一个位置，并返回它，而不改变数组的长度。
let arr = [1, 2, 3, 4, 5];
console.log(JSON.parse(JSON.stringify(arr)).fill(0, 2, 4)); // 输出: [1, 2, 0, 0, 5]
arr.copyWithin(0, 3, 5);
console.log(arr); // 输出: [4, 5, 3, 4, 5]
```
#### 删除
```js
// pop(): 删除数组最后一个元素。
// shift(): 删除数组第一个元素。
// splice(): 删除指定位置的元素。
const arr = [1, 2, 3, 4];
arr.pop(); // [1, 2, 3]
arr.shift(); // [2, 3]
arr.splice(1, 1); // [2] 删除索引1处的一个元素
```
#### 查找
```js
// indexOf(): 返回指定元素在数组中的第一个索引，如果不存在则返回 -1。
// lastIndexOf(): 返回指定元素在数组中的最后一个索引，如果不存在则返回 -1。
// includes(): 判断数组是否包含指定的元素，返回布尔值。
// find(): 返回符合条件的第一个元素。
// findIndex(): 返回符合条件的第一个元素的索引。
const arr = [1, 2, 3, 4];
arr.indexOf(3); // 2
arr.lastIndexOf(3); // 2
arr.includes(3); // true
arr.find(num => num > 2); // 3
arr.findIndex(num => num > 2); // 2
```
#### 遍历
```js
// forEach(): 对数组中的每个元素执行一次提供的函数。
// map(): 创建一个新数组，其结果是对原数组中的每个元素执行一次提供的函数后的返回值。写 React 最常用的数组方法
const arr = [1, 2, 3];
arr.forEach(num => console.log(num)); // 1 2 3
const newArr = arr.map(num => num * 2); // [2, 4, 6]
```
#### 筛选
```js
// filter(): 创建一个新数组，其包含通过所提供函数实现的测试的所有元素。
// every(): 测试数组的所有元素是否都通过了指定函数的测试。如果是，返回 true，否则返回 false。
// some(): 测试数组中的某些元素是否至少有一个通过了指定函数的测试。如果是，返回 true，否则返回 false。
const arr = [1, 2, 3, 4];
const evenNumbers = arr.filter(num => num % 2 === 0); // [2, 4]
let arr1 = [1, 2, 3, 2, 5];
console.log(arr.every(element => element < 10)); // 输出: true
console.log(arr.some(element => element % 2 === 0)); // 输出: true
```
#### 变换数组
```js
// reduce(): 对数组中的每个元素执行一个 reducer 函数，将其结果汇总为单个值。
// sort(): 对数组元素进行排序。
// reverse(): 反转数组中元素的顺序。
const arr = [1, 2, 3, 4];
const sum = arr.reduce((acc, num) => acc + num, 0); // 10
arr.sort((a, b) => b - a); // [4, 3, 2, 1]
arr.reverse(); // [1, 2, 3, 4]
```
#### 复制和合并
```js
// slice(): 返回一个新数组，是原数组的浅拷贝。
// concat(): 合并两个或多个数组，返回一个新数组。
// spread operator (...): 扩展运算符，用于复制数组或合并数组。
const arr = [1, 2, 3];
const copy = arr.slice(); // [1, 2, 3]
const merged = arr.concat([4, 5]); // [1, 2, 3, 4, 5]
const spreadMerged = [...arr, 4, 5]; // [1, 2, 3, 4, 5]
```
#### 转换数组
```js
// toString(): 将数组转换为一个字符串，其中每个数组元素用逗号分隔。
// join(): 将数组的所有元素连接成一个字符串，并可指定一个分隔符。
// toLocaleString(): 将数组的所有元素转换为本地字符串表示。
// Array.from(): 从类数组对象或可迭代对象创建一个新的数组实例。
// valueOf(): 返回的是数组本身
let arr = [1, 2, 3, 4, 5];
console.log(arr.toString()); // 输出: "1,2,3,4,5"
console.log(arr.join('-')); // 输出: "1-2-3-4-5"
let arr1 = [1, 'a', new Date()];
console.log(arr1.toLocaleString()); // 输出: "1,a,6/25/2024, 12:00:00 AM"（日期格式会根据本地设置有所不同）
let str = 'hello';
let arr = Array.from(str);
console.log(arr); // 输出: ["h", "e", "l", "l", "o"]
let colors = ["red", "blue", "green"];  
console.log(colors.valueOf())  // ["red", "blue", "green"]
```
#### 补充
```js
// 1、数组方法可以链式调用, 实现数组多操作
const arr = [1, 2, 3, 4, 5];
const result = arr.filter(num => num % 2 === 0).map(num => num * 2); // [4, 8]

// 2、数组快速去重实现：
[...new Set([1,2,3,2])]
```

### JavaScript 中 for...in 和 for...of 的区别是什么 ?
- 用法
  - for...in: 用于遍历对象的可枚举属性，包括其原型链上的可枚举属性
  - for...of: 用于遍历可迭代对象（如数组、字符串、Map、Set等）
- 返回值
  - for...in: 返回的是属性名（键名）
  - for...of: 返回的是每次迭代的值
- 遍历普通对象
  - for...in: 可以遍历普通对象，也可以遍历数组（但不推荐）
  - for...of: 不能直接用于遍历普通对象。
- 版本
  - for...in: ES3 语法
  - for...of: ES6 语法
- 遍历顺序
  - for...in: 不保证遍历顺序
  - for...of: 会按照迭代器定义的顺序进行遍历
- 性能
  - for...of 的性能比 for...in 更好，特别是在遍历数组时
- 继承属性
  - for...in 会遍历对象的原型链，而 for...of 不会
- 使用场景
  - for...in: 更适合用于遍历对象的属性
  - for...of: 更适合用于遍历数组或其他可迭代对象的值
```js
// for...in 示例
const obj = { a: 1, b: 2, c: 3 };
for (const key in obj) {
  console.log(key); // 输出: "a", "b", "c"
}

// for...of 示例
const arr = [1, 2, 3];
for (const value of arr) {
  console.log(value); // 输出: 1, 2, 3
}

// 补充
// for...in 可以用于遍历数组，但它可能会遍历到数组的非数字属性，导致意外的结果，例如：
const arr = [1, 2, 3];
arr.foo = 'bar';

for (const index in arr) {
  console.log(index); // 输出: "0", "1", "2", "foo"
}

// 如果需要同时获取数组的索引和值，可以结合使用 for...of 和 Array.entries()
const arr = ['a', 'b', 'c'];
for (const [index, value] of arr.entries()) {
  console.log(index, value); // 输出: 0 "a", 1 "b", 2 "c"
}
// 遍历对象也可以通过 Object.entries() + for ... of 实现
```

### JavaScript 如何使用 for...of 遍历对象 ?
for...of 语句不能直接用于遍历对象的。
首先，for...of 循环是用来遍历可迭代对象（ iterable objects ）的。
然而，普通的 JavaScript 对象默认是不可迭代的。
这就是为什么你不能直接使用 for...of 来遍历一个普通对象。
然而，我们可以通过一些方法来间接地实现这一目标，
比如使用 Object.keys、Object.values 或 Object.entries 将对象的属性转换为数组，
然后使用 for...of 进行遍历。
这里原理是数组是可迭代对象。
```js
const obj = { a: 1, b: 2, c: 3 };

// 遍历键
for (const key of Object.keys(obj)) {
  console.log(key, obj[key]);
}

// 遍历值
for (const value of Object.values(obj)) {
  console.log(value);
}

// 同时遍历键和值
for (const [key, value] of Object.entries(obj)) {
  console.log(key, value);
}

// 但是真的想使用 for...of 循环，也可以通过给对象添加 Symbol.iterator 属性来使其可迭代
// 这样做改变了对象的结构，可能会带来一些意想不到的副作用
const obj = { a: 1, b: 2, c: 3 };

obj[Symbol.iterator] = function* () {
  for (const key of Object.keys(this)) {
    yield [key, this[key]];
  }
};

for (const [key, value] of obj) {
  console.log(key, value);
}

// 1、在遍历对象时，需要注意性能问题。
// 对于大型对象，使用 for...in 循环可能会更高效，因为它不需要先创建一个数组。
// 但是，for...in 循环会遍历原型链上的属性，所以可以使用 Object.hasOwnProperty() 方法来检查属性是否是对象自身的属性
// 2、在日常开发中，推荐使用 Object.entries()，因为它既简洁又灵活。
// 而且它是相对安全，关注对象本身属性的
```

### const 对象的属性可以修改吗 ?
const 声明的对象，它的属性是可以修改的。
首先，const 关键字确实创建了一个常量，但这个"常量"指的是变量标识符的引用，而不是它所指向的值。
对于基本数据类型（如数字、字符串），const 确实会阻止值的改变。
但对于对象和数组这样的引用类型，情况就不同了。
```js
const myObject = { name: "Alice" };
myObject.name = "Bob"; // 这是允许的
console.log(myObject.name); // 输出: "Bob"

myObject = { name: "Charlie" }; // 这会抛出错误
// 因为 const 保证的是内存地址不变
// 而对象的属性存储在堆内存中，修改属性并不会改变对象本身的内存地址

// 如果真的想创建一个完全不可变的对象，可以使用 Object.freeze方法
// 但是这种方法仅冻结对象的第一层属性。深层冻结需要配合递归
```

### JavaScript 中 let 和 var 区别 ? 
```js
// 1、作用域不同
// var：声明的变量是函数作用域, 在整个函数中都有效
// 如果在函数外部使用 var，则变量的作用域是全局的
// let：声明的变量是块作用域, 只在最近的一对花括号 {} 内有效
if (true) {
  var a = 10;
  let b = 20;
}
console.log(a); // 10
console.log(b); // ReferenceError: b is not defined

// 2、变量提升
// var：会被提升到作用域的顶部（即可以在声明前使用，但值为 undefined），但赋值不会提升。
// let：同样会被提升，但会进入一个暂时性死区（Temporal Dead Zone, TDZ），在实际声明前访问会导致 ReferenceError
console.log(x); // undefined，因为 var 声明的 x 被提升了
var x = 5;
console.log(y); // ReferenceError: y is not defined，因为 y 处于暂时性死区
let y = 10;

// 3、重复声明
// var：允许在同一作用域内多次声明同一个变量，不会报错，后面的声明会覆盖前面的。
// let：在同一作用域内不允许重复声明同一个变量，会导致报错。
var a = 1;
var a = 2; // 允许，a 的值被覆盖为 2
let b = 1;
let b = 2; // SyntaxError: Identifier 'b' has already been declared

// 4、全局对象属性
// var：在全局作用域中声明的变量，会成为全局对象的属性（如浏览器中的 window 对象）。
// let：即使在全局作用域中声明，变量也不会成为全局对象的属性。
var a = 10;
console.log(window.a); // 10
let b = 20;
console.log(window.b); // undefined
```