### JavaScript 为什么要进行变量提升? 它导致了什么问题 ?
#### 变量提升原因
JavaScript进行变量提升（Hoisting）主要是由于其解释器的工作机制。<br>
在解析阶段，JavaScript引擎会将所有的变量声明和函数声明提升到其所在作用域的顶部，这样就可以在声明之前使用这些变量。<br>
不过需要注意的是，只有声明会被提升，初始化不会被提升。
#### 问题
- 潜在的bug难以察觉。例如，使用一个未经初始化的变量可能导致不可预测的行为。
- 代码的可读性和可维护性降低。因为阅读代码的人可能误解变量的实际作用范围和生命周期。
#### 如何避免问题
- 始终在使用变量之前进行声明和初始化。
- 使用 `let` 和 `const` 代替 `var`，因为它们不会在块作用域内被提升。
- 养成良好的代码组织和注释习惯，确保代码可读性。
#### 补充
```js
// 1、如何提升
// 在JavaScript内部，变量和函数声明会在代码的执行阶段之前被提前处理。例如，以下代码：
console.log(a); // undefined
var a = 5;
// 实际相当于
var a;
console.log(a); // undefined 
a = 5;
// 这解释了为什么控制台输出undefined而不是ReferenceError: a is not defined

// 2、函数提升与变量提升的区别
// 函数声明会被完全提升到顶部，可以在声明之前调用：
console.log(sayHi()); // "Hi"
function sayHi() {
  return "Hi";
}
// 而函数表达式则不会被提升，它们遵循变量提升的规则：
console.log(sayHello); // undefined
var sayHello = function() {
  return "Hello";
}
console.log(sayHello()); // "Hello"

// 3、块级作用域与提升
// 在ES6之前，JavaScript只有全局作用域和函数作用域，变量提升在这两个作用域内操作。
// 而在ES6中，引入了块级作用域（由let和const定义），块级作用域内的变量不会被提升到块外部。
{
  console.log(b); // ReferenceError
  let b = 10;
}
```

### 使用 let 全局声明变量，能通过 window 对象取到吗 ?
- 在 JavaScript 中，使用 let 声明的全局变量不能通过 window 对象直接访问。
- 与之相对的是使用 var 声明的全局变量和在最外层作用域中定义的函数，它们可以通过 window 对象访问。
```js
let globalLet = "This is a let variable";
var globalVar = "This is a var variable";
function globalFn() {
  return "This is a global function";
}
console.log(window.globalLet); // undefined
console.log(window.globalVar); // "This is a var variable"
console.log(window.globalFn);  // [Function: globalFn]
```
#### 补充
- 作用域和变量提升
`let` 和 `const` 声明的变量在块级作用域内有效，而 `var` 声明的变量在函数作用域或全局作用域内有效。<br>
此外，变量提升发生在 `var` 声明的变量上，而 `let` 和 `const` 则不会。<br>
不过，即使提升了，`let` 和 `const` 也会因 `TDZ`（Temporal Dead Zone，暂时性死区）的缘故不能在声明前使用。
- 全局对象（Global Object）与顶层作用域
虽然在浏览器环境中 window 对象是全局对象，但是在 `let` 和 `const` 引入之前，`var` 声明的变量和顶层（global scope）中的函数，都会被绑定到 window 对象上。<br>
然而，ECMAScript 2015（ES6）规范引入 `let` 和 `const`，它们虽然还是声明全局变量，但是不再绑定到 window 对象，这改善了全局变量污染的问题。
- 模块化和ES6
ES6 模块系统更进一步封装作用域，以`import`和`export`指令引入和输出模块内容，进一步减少全局变量污染。<br>
例如，在模块文件里声明的变量和函数不会成为 window 对象属性，这是因为模块会自动遵循一种更严格的作用域规则。
- TDZ（Temporal Dead Zone）详解
TDZ 指的是在 `let` 和 `const` 声明变量之前，该变量是不可访问的，虽然在代码运行到此位置时，变量已经存在了。<br>
TDZ 的出现是为了防止变量声明前被使用带来的意外错误。

### let、const 和 var 的区别是什么 ?
- 作用域：
  - `var` 在函数作用域内有效，并且能在函数外被访问（如果定义在全局作用域）。
  - `let` 和 `const` 在块级作用域（如花括号 {} 内）有效。
- 重新赋值：
  - `var` 可以重新赋值和重新声明。
  - `let` 可以重新赋值但不能重新声明。
  - `const` 既不能重新赋值，也不能重新声明。定义时必须初始化。
- 提升（Hoisting）：
  - `var` 会被提升到其作用域的顶部，但不会初始化。
  - `let` 和 `const` 也会被提升到作用域的顶部，但在初始化之前不能被访问（称为"暂时性死区"）。
#### 补充
- 全局对象属性：
在全局作用域下，用 `var` 声明的变量会成为全局对象的属性。<br>
例如，在浏览器环境中，`var` 声明的变量会成为 window 对象的属性。<br>
但是 `let` 和 `const` 不会。
- 块级作用域与变量泄漏：
使用 `var` 的变量在 `for` 循环中的表现可能会导致意外错误，因为 `var` 没有块级作用域，且循环变量会在全局或函数作用域内共享。<br>
使用 `let` 可以确保每次迭代都有一个新的绑定，以便解决这个问题。
- 暂时性死区：
暂时性死区是指在变量声明之前访问变量会导致引用错误，这对于 `let` 和 `const` 变量来说都是成立的。<br>
这其实是一个非常有用的特性，可以防止因变量提升带来的潜在错误。
- 最佳实践：
使用 `const` 声明那些不会改变的变量是个好习惯，可以强调代码的不可变性。<br>
只有在明确需要重新赋值的情况下使用 `let`。<br>
在现代 JavaScript 编程中，几乎不会再用到 `var` 了，因为 `let` 和 `const` 能更好地处理作用域和提升问题。

### 说说你对 JS 作用域的理解 ?
#### 含义
作用域，其实就是一个变量或函数在代码中的可访问范围。
#### 分类
- 全局作用域：
  - 定义在所有函数体以及其他代码块之外的变量，称为全局变量。
  - 它们在脚本的任何地方都是可访问的。
- 局部作用域：
  - 局部变量定义在函数内或代码块内（如 `if、for` 块），它们只能在函数内或代码块内访问。
  - 局部作用域又可细分为函数作用域和块作用域。
  - 函数作用域：
    - 只在函数内部可见的变量，这种作用域在早期的 JavaScript 中非常常见。
  - 块作用域：
    - ES6 引入的 `let` 和 `const` 关键字，使得可以在块级代码（类似 {}）内部定义变量，即所谓的块作用域。
#### 补充
- 提升（Hoisting）：
  - 发生在变量声明和函数声明上，旨在解释为什么即使在声明之前使用变量也不会报错。
  - 变量提升是指不论变量在代码中的位置，它们会被提升到代码的顶部进行声明，
  - 而函数提升不仅是声明，它会把整个函数提升到顶部。
- 作用域链：
  - 当查找一个变量时，JavaScript 引擎会首先在当前作用域中查找，
  - 如果未找到，它会沿着作用域链向上查找，直到全局作用域。
  - 如果还未找到，则返回 `undefined`。
- 闭包（Closure）：
  - 函数内定义的函数能够访问外部函数的变量，这就是闭包。
  - 它是一种特殊的作用域情况，能让我们创建私有变量和函数。
- 立即执行函数表达式（IIFE）：
  - 一种常见的技术，通过定义和立即调用一个匿名函数，创建一个新的作用域，从而保护内部变量不受外部干扰。
  - 同时它也会避免全局变量污染的问题。
- 严格模式（Strict Mode）：
  - 严格模式扩展了 ECMAScript 3 的语法和语义范围，使 JavaScript 在更严格的条件下执行，有助于更好地调试和提升代码的安全性。
- 模块化（Modules）：
  - 现代 JavaScript 越来越依赖模块化，通过 import 和 export 关键字，可以在不同模块之间共享代码，避免作用域污染，并且更好地组织代码。

### 什么是 JavaScript 的临时性死区 ?
#### 含义
JavaScript 中的临时性死区（Temporal Dead Zone, TDZ）是指在代码块中使用 `let` 或 `const` 变量之前，这些变量暂时无法访问的区域。<br>
虽然在语法上已经声明了这些变量，但如果尝试在声明之前使用它们，就会抛出 `ReferenceError` 错误。
#### 作用
TDZ 确保开发者不会在变量被初始化之前使用它们，从而避免了很多潜在的错误，确保代码的真实性和可靠性。
#### 补充
```js
// 1、临时性死区
// 这里发生了临时性死区
console.log(a); // ReferenceError: a is not defined
let a = 10;

// 2、Hoisting（变量提升）
// var 变量的一个特点是变量提升，它的声明会被提升到函数或全局作用域的顶部。
// 不过，变量声明虽然提升，但不会初始化。
// 因此，在初始化之前使用变量会得到 undefined。
// 与 var 不同，let 和 const 不会被提升，这也是 TDZ 的基本原则

// 变量提升的例子
console.log(b); // undefined
var b = 20;

// TDZ 的例子
console.log(c); // ReferenceError: c is not defined
let c = 30;

// 3、块级作用域（Block Scope）
// let 和 const 引入了块级作用域，这使得变量只能在其声明的代码块{}内有效。
// 同样，这些变量也在 TDZ 中，直到执行到声明语句为止
{
  console.log(d); // ReferenceError: d is not defined
  let d = 40;
}

// 4、const 的特点
// 与 let 类似，const 声明的变量也有 TDZ，并且要注意的是，const 声明的变量一旦初始化就不允许重新赋值。
// 如果需要声明一个不变的常量，const 是一个很好的选择
{
  console.log(e); // ReferenceError: e is not defined
  const e = 50;
  e = 60; // TypeError: Assignment to constant variable.
}
```

### 说说你对 JavaScript 作用域、作用域链的理解 ?
- 在 JavaScript 中，作用域是指代码在某个特定范围内能够访问变量和函数的集合。
- 主要有两类作用域：全局作用域和局部作用域（包括函数作用域和块级作用域）。
  - 全局作用域：在浏览器环境中，最外层的作用域为全局作用域，所有在全局作用域中声明的变量和函数都可以在任何地方访问到。
  - 局部作用域：
    - 函数作用域：在函数内部声明的变量只在该函数内部可见。
    - 块级作用域：用 `let` 和 `const` 声明的变量，其作用域只在定义所在的代码块内（如 {} 大括号内）。

- 作用域链则是当变量在当前作用域中无法找到时，JavaScript 会一层一层地向外查找，直到找到变量或到达全局作用域。
- 作用域链：
  - 当在某个作用域中引用一个变量时，JavaScript 引擎会尝试先在当前作用域查找，
  - 如果未找到，则会沿着作用域链向外查找，直到全局作用域。
  - 未找到时会报 `ReferenceError`。

- 作用域和作用域链在 JavaScript 编程中扮演着重要角色，有助于组织代码，避免冲突。
#### 补充
- 词法作用域：
  - 词法作用域（Lexical Scope）指的是作用域在代码书写时就已经确定了，而不是在运行时确定。
  - 在 JavaScript 中，作用域是基于程序的书写结构来决定的，而非调用关系。
- 变量提升：
  - JavaScript 的变量和函数声明在编译阶段会被“提升”到所属作用域的顶端，但 `let` 和 `const` 声明的变量不会被提升。
  - 变量提升会导致一些令人困惑的行为，因此建议尽量在作用域的顶部声明变量。
- 闭包：
  - 闭包是指函数内部的变量即使在函数调用结束后仍然可以被外部函数访问。
  - 闭包依赖于作用域链，它能够看见自己作用域中的变量以及在外部作用域中的变量。这是因为函数保存了对其词法作用域的引用。
- 块级作用域：
  - ES6 引入了块级作用域，可以使用 `let` 和 `const` 来定义块级作用域变量，在 {} 代码块内才有效，这样更好地控制变量的生命周期和作用域范围。
- 立即执行函数表达式（IIFE）：
  - IIFE 是一种常见的 JavaScript 编程模式，通过立即调用匿名函数来创建一个新的作用域，从而避免污染全局作用域，用来封装独立的代码模块。

### 什么是 JavaScript 的执行上下文 ?
- JavaScript 的执行上下文（Execution Context）是指 JavaScript 代码在执行时所处的环境。
- 执行上下文决定了代码在运行时所能访问的变量、函数、以及如何调用，其中包含了变量对象、作用域链和 this 值。
#### 补充
- 执行上下文的类型
  - 全局执行上下文：
    - 这就是默认的执行上下文，当 JavaScript 代码开始执行时，全局执行上下文会首先被创建。
    - 在浏览器环境中，全局对象是 window，在 Node.js 环境下，全局对象是 `global`。
  - 函数执行上下文：
    - 每当调用一个函数时，都会创建一个新的函数执行上下文。
    - 每个函数调用都有自己的上下文，并且它们可以嵌套。
  - Eval 执行上下文：
    - 这种上下文是由 `eval` 函数引发的，几乎没有人会建议使用它，因为它会使得代码难以维护和调试。
- 执行上下文的组件
  - 变量对象（Variable Object, VO）：
    - 包含了函数的所有形参、内部变量和函数声明。对于函数上下文来说，它被称为活动对象（Activation Object, AO）。
  - 作用域链（Scope Chain）：
    - 在执行上下文中，作用域链用来解析变量，它包含当前上下文的变量对象以及所有父级（词法）上下文的变量对象。
  - this 值：
    - 在不同的执行上下文中 `this` 的值不同。
    - 在全局上下文中，`this` 指向全局对象；
    - 在函数上下文中，`this` 的值取决于函数的调用方式（比如作为对象的方法调用时 `this` 指向对象）。
- 执行上下文的生命周期
  - 创建阶段：
    - 创建变量对象：包括函数参数，函数声明，变量声明（但是不会立刻赋值）。
    - 创建作用域链：形成一个作用域链，并将其与当前执行上下文关联。
    - 确定 `this` 值：根据调用位置，确定当前上下文的 `this` 值。
  - 执行阶段：
    - 变量分配：变量赋值和函数引用开始执行。
    - 执行代码：根据代码逻辑逐行执行，完成整个执行过程。


